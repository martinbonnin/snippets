 ************************************************************************
 * $Id: arabic_shape.patch,v 1.8.2.1 2003/02/26 21:27:17 nadim Exp $
 *
 * ------------
 * Description:
 * ------------
 *  Patch to add necessary Arabic support to Vim.
 *  Patch and info can be found on arabeyes' page,
 *
 *    http://www.arabeyes.org/project.php?proj=VIM
 *
 *  Read the accompanying README file for details.
 *
 ************************************************************************

--- ./Makefile.orig	Tue Jul  9 13:40:27 2002
+++ ./Makefile	Wed Feb 12 11:20:15 2003
@@ -275,6 +275,8 @@
 # more source files
 SRC_MORE =	\
 		src/diff.c \
+		src/arabic.c \
+		src/arabic.h \
 		src/farsi.c \
 		src/farsi.h \
 		src/fold.c \
--- ./src/Makefile.orig	Tue Feb  4 11:03:31 2003
+++ ./src/Makefile	Wed Feb 26 13:54:01 2003
@@ -2208,7 +2208,7 @@
  gui.h option.h ex_cmds.h proto.h globals.h farsi.h
 objects/ex_getln.o: ex_getln.c vim.h auto/config.h feature.h os_unix.h \
  auto/osdef.h ascii.h keymap.h term.h macros.h structs.h regexp.h \
- gui.h option.h ex_cmds.h proto.h globals.h farsi.h
+ gui.h option.h ex_cmds.h proto.h globals.h farsi.h arabic.h
 objects/fileio.o: fileio.c vim.h auto/config.h feature.h os_unix.h \
  auto/osdef.h ascii.h keymap.h term.h macros.h structs.h regexp.h \
  gui.h option.h ex_cmds.h proto.h globals.h farsi.h
@@ -2226,7 +2226,7 @@
  gui.h option.h ex_cmds.h proto.h globals.h farsi.h version.h
 objects/main.o: main.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
  ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h option.h \
- ex_cmds.h proto.h globals.h farsi.h farsi.c
+ ex_cmds.h proto.h globals.h farsi.h farsi.c arabic.h arabic.c
 objects/mark.o: mark.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
  ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h option.h \
  ex_cmds.h proto.h globals.h farsi.h
@@ -2241,7 +2241,7 @@
  ex_cmds.h proto.h globals.h farsi.h
 objects/message.o: message.c vim.h auto/config.h feature.h os_unix.h \
  auto/osdef.h ascii.h keymap.h term.h macros.h structs.h regexp.h \
- gui.h option.h ex_cmds.h proto.h globals.h farsi.h
+ gui.h option.h ex_cmds.h proto.h globals.h farsi.h arabic.h
 objects/misc1.o: misc1.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
  ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h option.h \
  ex_cmds.h proto.h globals.h farsi.h version.h
@@ -2253,7 +2253,7 @@
  ex_cmds.h proto.h globals.h farsi.h
 objects/mbyte.o: mbyte.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
  ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h option.h \
- ex_cmds.h proto.h globals.h farsi.h
+ ex_cmds.h proto.h globals.h farsi.h arabic.h
 objects/normal.o: normal.c vim.h auto/config.h feature.h os_unix.h \
  auto/osdef.h ascii.h keymap.h term.h macros.h structs.h regexp.h \
  gui.h option.h ex_cmds.h proto.h globals.h farsi.h
@@ -2262,7 +2262,7 @@
  ex_cmds.h proto.h globals.h farsi.h
 objects/option.o: option.c vim.h auto/config.h feature.h os_unix.h \
  auto/osdef.h ascii.h keymap.h term.h macros.h structs.h regexp.h \
- gui.h option.h ex_cmds.h proto.h globals.h farsi.h
+ gui.h option.h ex_cmds.h proto.h globals.h farsi.h arabic.h
 objects/os_unix.o: os_unix.c vim.h auto/config.h feature.h os_unix.h \
  auto/osdef.h ascii.h keymap.h term.h macros.h structs.h regexp.h \
  gui.h option.h ex_cmds.h proto.h globals.h farsi.h os_unixx.h
@@ -2274,13 +2274,13 @@
  gui.h option.h ex_cmds.h proto.h globals.h farsi.h
 objects/regexp.o: regexp.c vim.h auto/config.h feature.h os_unix.h \
  auto/osdef.h ascii.h keymap.h term.h macros.h structs.h regexp.h \
- gui.h option.h ex_cmds.h proto.h globals.h farsi.h
+ gui.h option.h ex_cmds.h proto.h globals.h farsi.h arabic.h
 objects/screen.o: screen.c vim.h auto/config.h feature.h os_unix.h \
  auto/osdef.h ascii.h keymap.h term.h macros.h structs.h regexp.h \
- gui.h option.h ex_cmds.h proto.h globals.h farsi.h
+ gui.h option.h ex_cmds.h proto.h globals.h farsi.h arabic.h
 objects/search.o: search.c vim.h auto/config.h feature.h os_unix.h \
  auto/osdef.h ascii.h keymap.h term.h macros.h structs.h regexp.h \
- gui.h option.h ex_cmds.h proto.h globals.h farsi.h
+ gui.h option.h ex_cmds.h proto.h globals.h farsi.h arabic.h
 objects/syntax.o: syntax.c vim.h auto/config.h feature.h os_unix.h \
  auto/osdef.h ascii.h keymap.h term.h macros.h structs.h regexp.h \
  gui.h option.h ex_cmds.h proto.h globals.h farsi.h
--- ./src/globals.h.orig	Tue Nov 19 15:51:47 2002
+++ ./src/globals.h	Wed Feb 26 13:54:01 2003
@@ -121,6 +121,9 @@
  * Functions for putting characters in the command line,
  * while keeping ScreenLines[] updated.
  */
+#ifdef FEAT_ARABIC
+EXTERN int	msg_rl;
+#endif
 EXTERN int	msg_col;
 EXTERN int	msg_row;
 EXTERN int	msg_scrolled;	/* Number of screen lines that windows have
@@ -1080,6 +1083,9 @@
 #ifndef FEAT_FKMAP
 EXTERN char_u e_nofarsi[]	INIT(=N_("E27: Farsi cannot be used: Not enabled at compile time\n"));
 #endif
+#ifndef FEAT_ARABIC
+EXTERN char_u e_noarabic[] 	INIT(=N_("E800: Arabic cannot be used: Not enabled at compile time\n"));
+#endif
 #if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_SYN_HL)
 EXTERN char_u e_nogroup[]	INIT(=N_("E28: No such highlight group name: %s"));
 #endif
@@ -1158,4 +1164,10 @@
  */
 #ifdef FEAT_FKMAP
 # include "farsi.h"
+#endif
+/*
+ * Optional Arabic support. Include it here, so EXTERN and INIT are defined.
+ */
+#ifdef FEAT_ARABIC
+# include "arabic.h"
 #endif
--- ./src/feature.h.orig	Fri Sep 27 16:58:01 2002
+++ ./src/feature.h	Wed Feb 12 11:20:15 2003
@@ -314,6 +314,17 @@
 #endif
 
 /*
+ * +arabic		Arabic Keymap support.
+ *			Needs FEAT_RIGHTLEFT.
+ */
+#ifdef FEAT_BIG
+# ifndef FEAT_RIGHTLEFT
+#   define FEAT_RIGHTLEFT
+# endif
+# define FEAT_ARABIC
+#endif
+
+/*
  * +emacs_tags		When FEAT_EMACS_TAGS defined: Include support for
  *			emacs style TAGS file.
  */
--- ./src/option.h.orig	Mon Oct 14 10:31:34 2002
+++ ./src/option.h	Wed Feb 26 13:54:01 2003
@@ -462,6 +462,9 @@
 EXTERN int	p_fkmap;	/* 'fkmap' */
 EXTERN int	p_altkeymap;	/* 'altkeymap' */
 # endif
+# ifdef FEAT_ARABIC
+EXTERN int	p_arabic;	/* 'arabic' */
+# endif
 #endif
 #ifdef FEAT_TITLE
 EXTERN int	p_icon;		/* 'icon' */
--- ./src/main.c.orig	Tue Feb  4 11:28:06 2003
+++ ./src/main.c	Wed Feb 26 13:54:01 2003
@@ -591,6 +591,18 @@
 		    argv_idx = -1;	/* skip to next argument */
 		break;
 
+	    case 'A':		/* "-A" start in Arabic mode: rl + arabic set */
+#ifdef FEAT_ARABIC
+		p_arabic = TRUE;
+#ifdef FEAT_GUI
+		curwin->w_p_rl = gui.starting;
+#endif
+#else
+		mch_errmsg(_(e_noarabic));
+		mch_exit(2);
+#endif
+		break;
+
 	    case 'b':		/* "-b" binary mode */
 		bin_mode = TRUE;    /* postpone to after reading .exrc files */
 		break;
@@ -1379,6 +1391,9 @@
     if (curwin->w_p_rl && p_altkeymap)
     {
 	p_hkmap = FALSE;	/* Reset the Hebrew keymap mode */
+#ifdef FEAT_ARABIC
+	p_arabic = FALSE;	/* Reset the Arabic keymap mode */
+#endif
 	p_fkmap = TRUE;		/* Set the Farsi keymap mode */
     }
 #endif
@@ -2302,6 +2317,9 @@
     main_msg(_("-f\t\t\tDon't use newcli to open window"));
     main_msg(_("-dev <device>\t\tUse <device> for I/O"));
 #endif
+#ifdef FEAT_ARABIC
+    main_msg(_("-A\t\t\tstart in Arabic mode"));
+#endif
 #ifdef FEAT_RIGHTLEFT
     main_msg(_("-H\t\t\tstart in Hebrew mode"));
 #endif
@@ -2884,4 +2902,11 @@
  */
 #if defined(FEAT_FKMAP) || defined(PROTO)
 # include "farsi.c"
+#endif
+
+/*
+ * When FEAT_ARABIC is defined, also compile the Arabic source code.
+ */
+#if defined(FEAT_ARABIC) || defined(PROTO)
+# include "arabic.c"
 #endif
--- ./src/mbyte.c.orig	Mon Oct 28 21:15:53 2002
+++ ./src/mbyte.c	Wed Feb 26 13:54:01 2003
@@ -1130,6 +1130,23 @@
     return c;
 }
 
+#ifdef FEAT_ARABIC
+/*
+ * Check whether we are dealing with Arabic combining characters.
+ * Note: these are NOT really composing characters!
+ */
+    int
+arabic_combine(one, two)
+    int	       one;
+    int        two;
+{
+    return ((one == a_LAM) && ((two == a_ALEF_MADDA)	   ||
+			       (two == a_ALEF_HAMZA_ABOVE) ||
+			       (two == a_ALEF_HAMZA_BELOW) ||
+			       (two == a_ALEF)));
+}
+#endif
+
 /*
  * Convert a UTF-8 byte string to a wide chararacter.  Also get up to two
  * composing characters.
@@ -1148,7 +1165,12 @@
     len = utf_ptr2len_check(p);
     /* Only accept a composing char when the first char isn't illegal. */
     if ((len > 1 || *p < 0x80)
-	    && p[len] >= 0x80 && utf_iscomposing(cc = utf_ptr2char(p + len)))
+            && p[len] >= 0x80 && (utf_iscomposing(cc = utf_ptr2char(p + len))
+#ifdef FEAT_ARABIC
+			       || arabic_combine(utf_ptr2char(p),
+						 cc = utf_ptr2char(p + len))
+#endif
+			     ))
     {
 	*p1 = cc;
 	len += utf_ptr2len_check(p + len);
@@ -1273,7 +1295,12 @@
      */
     for (;;)
     {
-	if (p[len] < 0x80 || !utf_iscomposing(utf_ptr2char(p + len)))
+	if (p[len] < 0x80 || (!utf_iscomposing(utf_ptr2char(p + len))
+#ifdef FEAT_ARABIC
+			      && !arabic_combine(utf_ptr2char(p),
+						 utf_ptr2char(p + len))
+#endif
+			     ))
 	    return len;
 
 	/* Skip over composing char */
@@ -1965,6 +1992,7 @@
 {
     char_u	*q;
     char_u	*s;
+    char_u	*j;
 
     if (*p < 0x80)		/* be quick for ASCII */
 	return 0;
@@ -1982,7 +2010,23 @@
 	/* Check for illegal sequence. */
 	if (utf8len_tab[*q] != (int)(s - q + 1))
 	    return 0;
-	if (q <= base || !utf_iscomposing(utf_ptr2char(q)))
+
+#ifdef FEAT_ARABIC
+	/* Advance to get a sneak-peak at the next char */
+	j = q;
+	--j;
+	/* Move s to the last byte of this char. */
+	for (s = j; (s[1] & 0xc0) == 0x80; ++s)
+	    ;
+	/* Move q to the first byte of this char. */
+	while (j > base && (*j & 0xc0) == 0x80)
+	    --j;
+#endif
+	if (q <= base || (!utf_iscomposing(utf_ptr2char(q))
+#ifdef FEAT_ARABIC
+			  && !arabic_combine(utf_ptr2char(j), utf_ptr2char(q))
+#endif
+			 ))
 	    break;
     }
 
--- ./src/option.c.orig	Mon Jan 20 16:00:55 2003
+++ ./src/option.c	Wed Feb 26 13:54:01 2003
@@ -233,6 +233,10 @@
 static long	p_sts_nopaste;
 static int	p_ai_nopaste;
 
+# ifdef FEAT_ARABIC
+static int	on_arabic;
+# endif
+
 struct vimoption
 {
     char	*fullname;	/* full option name */
@@ -311,6 +315,13 @@
 			    (char_u *)224L,
 #endif
 					    (char_u *)0L}},
+    {"arabic",	    "arab", P_BOOL|P_VI_DEF|P_VIM,
+#ifdef FEAT_ARABIC
+			    (char_u *)&p_arabic, PV_NONE,
+#else
+			    (char_u *)NULL, PV_NONE,
+#endif
+			    {(char_u *)FALSE, (char_u *)0L}},
     {"allowrevins", "ari",  P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_RIGHTLEFT
 			    (char_u *)&p_ari, PV_NONE,
@@ -5868,6 +5879,19 @@
      * In case some second language keymapping options have changed, check
      * and correct the setting in a consistent way.
      */
+
+    /*
+     * If hkmap or fkmap are set, reset Arabic keymapping.
+     */
+    if ( (p_hkmap || p_fkmap) && p_altkeymap)
+    {
+        p_altkeymap = p_fkmap;
+#ifdef FEAT_ARABIC
+	p_arabic = 0;
+#endif
+	(void)init_chartab();
+    }
+
     /*
      * If hkmap set, reset Farsi keymapping.
      */
@@ -5875,6 +5899,9 @@
     {
 	p_altkeymap = 0;
 	p_fkmap = 0;
+#ifdef FEAT_ARABIC
+	p_arabic = 0;
+#endif
 	(void)init_chartab();
     }
 
@@ -5885,8 +5912,113 @@
     {
 	p_altkeymap = 1;
 	p_hkmap = 0;
+#ifdef FEAT_ARABIC
+	p_arabic = 0;
+#endif
+	(void)init_chartab();
+    }
+
+    /*
+     * If arabic set, reset Farsi/Hebrew keymapping.
+     */
+#ifdef FEAT_ARABIC
+    if (p_arabic)
+    {
+      on_arabic = 1;
+# ifdef FEAT_GUI
+	if (gui.starting || gui.in_use)
+	{
+            /* Unless its being set/reset explicitly, set rightleft mode */
+	    if ((int *)varp != &curwin->w_p_rl)
+	    {
+	        curwin->w_p_rl = 1;
+	        changed_window_setting();
+	    }
+        }
+# endif
+	/* Force-set the necessary encoding for arabic */
+	p_enc = "utf-8";
+	mb_init();
+# ifdef FEAT_TITLE
+	need_maketitle = TRUE;
+# endif
+
+# ifdef FEAT_MBYTE
+	/* Allow user to toggle this setting */
+        if ((int *)varp != &p_deco)
+            p_deco = 1;
+# endif
+
+# ifdef FEAT_KEYMAP
+	/* Force-set the necessary keymap for arabic */
+	curbuf->b_p_keymap = "arabic";
+
+	/* When successfully installed a new keymap switch on using it. */
+	if (keymap_init() == NULL)
+	{
+	    curbuf->b_p_iminsert = B_IMODE_LMAP;
+	    if (curbuf->b_p_imsearch != B_IMODE_USE_INSERT)
+		curbuf->b_p_imsearch = B_IMODE_LMAP;
+	    set_iminsert_global();
+	    set_imsearch_global();
+# ifdef FEAT_WINDOWS
+	    status_redraw_curbuf();
+# endif
+	}
+# endif
+	p_altkeymap = 0;
+	p_hkmap = 0;
+	p_fkmap = 0;
+	(void)init_chartab();
+    }
+
+    /* Account for the noarabic option */
+    if ((int *)varp == &p_arabic && !p_arabic && on_arabic)
+    {
+        /* disable the mode bit */
+        on_arabic = 0;
+
+# ifdef FEAT_GUI
+	if (gui.starting || gui.in_use)
+	{
+            /* Unless its being set/reset explicitly, reset rightleft mode */
+	    if ((int *)varp != &curwin->w_p_rl)
+	    {
+	        curwin->w_p_rl = 0;
+	        changed_window_setting();
+	    }
+        }
+# endif
+	/* Revert to default value for 'encoding' (p_enc) */
+	p_enc = "";
+	if ( enc_default() != OK )
+	{
+	    p_enc = "latin1";
+	    mb_init();
+        }
+# ifdef FEAT_TITLE
+	need_maketitle = TRUE;
+# endif
+
+# ifdef FEAT_MBYTE
+        p_deco = 0;
+# endif
+
+# ifdef FEAT_KEYMAP
+	/* Revert to the default keymap */
+	curbuf->b_p_iminsert = B_IMODE_NONE;
+	curbuf->b_p_imsearch = B_IMODE_USE_INSERT;
+# endif
 	(void)init_chartab();
     }
+
+    {
+    extern int arab_debug;
+    if ( arab_debug )
+        fprintf(stderr,"option.c - p_arabic=%d, rightleft=%d\n", p_arabic, curwin->w_p_rl);
+    }
+#endif
+
 #endif
 
     /*
--- ./src/regexp.c.orig	Fri Jan  3 21:47:58 2003
+++ ./src/regexp.c	Wed Feb 26 13:54:01 2003
@@ -1982,6 +1982,7 @@
 		    if (enc_utf8)
 		    {
 			int	off;
+			int     len;
 
 			/* Need to get composing character too, directly
 			 * access regparse for that, because skipchr() skips
@@ -1995,7 +1996,16 @@
 			{
 			    off += utf_ptr2len_check(regparse + off);
 			    c = utf_ptr2char(regparse + off);
-			    if (!utf_iscomposing(c))
+#ifdef FEAT_ARABIC
+			    len = utf_ptr2len_check(regparse + off);
+#endif
+			    if (!utf_iscomposing(c)
+#ifdef FEAT_ARABIC
+				&& !arabic_combine(
+					    utf_ptr2char(regparse + off - len),
+					    utf_ptr2char(regparse + off))
+#endif
+			       )
 				break;
 			    regmbc(c);
 			}
@@ -3428,8 +3438,14 @@
 			return FALSE;
 #ifdef FEAT_MBYTE
 		    /* Check for following composing character. */
-		    if (enc_utf8 && utf_iscomposing(
-					       utf_ptr2char(reginput + len)))
+		    if (enc_utf8 && (utf_iscomposing(
+					        utf_ptr2char(reginput + len))
+#ifdef FEAT_ARABIC
+				     || arabic_combine(
+						utf_ptr2char(reginput),
+						utf_ptr2char(reginput + len))
+#endif
+				     ))
 			return FALSE;
 #endif
 		    reginput += len;
--- ./src/ex_getln.c.orig	Fri Jan  3 20:33:31 2003
+++ ./src/ex_getln.c	Wed Feb 26 13:54:01 2003
@@ -200,6 +200,13 @@
     ccline.cmdlen = ccline.cmdpos = 0;
     ccline.cmdbuff[0] = NUL;
 
+#ifdef FEAT_ARABIC
+    if ( curwin->w_p_rl && ((firstc == '/') || (firstc == '?')) )
+	msg_rl = 1;
+    else
+	msg_rl = 0;
+#endif
+
     redir_off = TRUE;		/* don't redirect the typed command */
     if (!cmd_silent)
     {
@@ -794,6 +801,11 @@
 		    ccline.cmdbuff = NULL;
 		    if (!cmd_silent)
 		    {
+#ifdef FEAT_ARABIC
+		      if ( msg_rl )
+			  msg_col = Columns;
+		      else
+#endif
 			msg_col = 0;
 			msg_putchar(' ');		/* delete ':' */
 		    }
@@ -1442,10 +1454,20 @@
 	    msg_starthere();
 	    redrawcmdline();
 	    did_incsearch = TRUE;
+
+#ifdef FEAT_ARABIC
+	    msg_rl = 0;
+#endif
+
 	}
 #else
 	;
 #endif
+
+#ifdef FEAT_ARABIC
+ 	if ( msg_rl )
+	  redrawcmd();
+#endif
     }
 
 returncmd:
@@ -2052,7 +2074,12 @@
 	 * the character before it.  There could be two of them. */
 	c = 0;
 	while (enc_utf8 && ccline.cmdpos > 0
-	     && utf_iscomposing(utf_ptr2char(ccline.cmdbuff + ccline.cmdpos)))
+	     && (utf_iscomposing(utf_ptr2char(ccline.cmdbuff + ccline.cmdpos))
+#ifdef FEAT_ARABIC
+		 || arabic_combine((utf_ptr2char(ccline.cmdbuff + ccline.cmdpos)),
+				   (utf_ptr2char(ccline.cmdbuff + ccline.cmdpos)+1))
+#endif
+		 ))
 	{
 	    c = (*mb_head_off)(ccline.cmdbuff,
 				      ccline.cmdbuff + ccline.cmdpos - 1) + 1;
@@ -2157,6 +2184,19 @@
     cursorcmd();
 }
 
+#ifdef FEAT_ARABIC
+    void
+redraw_msg(msg_ptr, msg_len)
+    char_u *msg_ptr;
+    int     msg_len;
+{
+  /* Re-populate the ccline for redisplay for the '/return' cases */
+  ccline.cmdbuff = msg_ptr;
+  ccline.cmdlen  = msg_len;
+  redrawcmd();
+}
+#endif
+
     static void
 redrawcmdprompt()
 {
@@ -2222,10 +2262,26 @@
 {
     if (cmd_silent)
 	return;
+
+#ifdef FEAT_ARABIC
+	if ( msg_rl )
+	{
+	    msg_row = cmdline_row  + (ccline.cmdspos / (int)(Columns - 1));
+	    msg_col = (int)Columns - (ccline.cmdspos % (int)(Columns - 1)) - 1;
+
+	    if (msg_row <= 0)
+		msg_row = Rows - 1;
+	}
+	else
+#endif
+	{
     msg_row = cmdline_row + (ccline.cmdspos / (int)Columns);
     msg_col = ccline.cmdspos % (int)Columns;
+
     if (msg_row >= Rows)
 	msg_row = Rows - 1;
+	}
+
     windgoto(msg_row, msg_col);
 #ifdef MCH_CURSOR_SHAPE
     mch_update_cursor();
@@ -2237,6 +2293,11 @@
     int		    clr;
 {
     msg_start();
+#ifdef FEAT_ARABIC
+    if ( msg_rl )
+      msg_col = Columns-1;
+    else
+#endif
     msg_col = 0;	    /* always start in column 0 */
     if (clr)		    /* clear the bottom line(s) */
 	msg_clr_eos();	    /* will reset clear_cmdline */
--- ./src/screen.c.orig	Wed Jan 29 08:51:51 2003
+++ ./src/screen.c	Wed Feb 26 13:54:01 2003
@@ -4133,6 +4133,37 @@
 		{
 		    ScreenLinesC1[off_to] = ScreenLinesC1[off_from];
 		    ScreenLinesC2[off_to] = ScreenLinesC2[off_from];
+#ifdef FEAT_ARABIC
+#ifdef FEAT_GUI
+		    /* Do this only in GUI mode */
+		    if (gui.in_use)
+		    {
+			/* PROBLEM: need next char to make shaping decisions */
+			/* IDEAL fix - the screenlines should be completely
+			               updated before a call to display is made
+				   *OR*
+				       the loop should be made from
+                                       right-to-left in rightleft mode; the
+                                       current variables redraw_this and
+                                       redraw_next simply aren't correct in
+                                       rightleft mode
+			 */
+			if ( (col+1) != endcol )
+			{
+			   ScreenLines[off_to+1] = ScreenLines[off_from+1];
+
+			   ScreenAttrs[off_to+1] = ScreenAttrs[off_from+1];
+
+			   ScreenLinesUC[off_to+1] = ScreenLinesUC[off_from+1];
+			   ScreenLinesC1[off_to+1] = ScreenLinesC1[off_from+1];
+			   ScreenLinesC2[off_to+1] = ScreenLinesC2[off_from+1];
+
+			   /* again - redraw in rightleft mode is buggy */
+			   redraw_next = TRUE;
+			}
+		    }
+#endif
+#endif
 		}
 	    }
 	    if (char_cells == 2)
@@ -5615,7 +5646,12 @@
 
     /* Outputting the last character on the screen may scrollup the screen.
      * Don't to it!  Mark the character invalid (update it when scrolled up) */
-    if (row == screen_Rows - 1 && col == screen_Columns - 1)
+    if (row == screen_Rows - 1 && col == screen_Columns - 1
+#ifdef FEAT_ARABIC
+        /* account for that first command-line character in rightleft mode */
+	&& !msg_rl
+#endif
+	)
     {
 	ScreenAttrs[off] = (sattr_T)-1;
 	return;
@@ -5644,7 +5680,34 @@
 	char_u	    buf[MB_MAXBYTES + 1];
 
 	/* Convert UTF-8 character to bytes and write it. */
+	int c1 = 0;
+	int c2 = 0;
+	int c, clen;
+
 	buf[utfc_char2bytes(off, buf)] = NUL;
+
+#if defined(FEAT_ARABIC) && defined(FEAT_GUI)
+	/* Do this only in GUI mode */
+	if (gui.in_use)
+	{
+	    /* Attain character encoding for Arabic shaping */
+	    c = utfc_ptr2char(buf, &c1, &c2);
+
+	    /* intercept character and shape it (only if its Arabic) */
+	    c = shape_arabic(off, c);
+
+	    /* Reintroduce character to display */
+	    clen = (*mb_char2bytes)(c, buf);
+
+	    /* Account for any Tanween/Harakat */
+	    if (ScreenLinesC1[off])
+	    {
+		clen += (*mb_char2bytes)(ScreenLinesC1[off], buf+clen);
+	    }
+
+	    buf[clen] = NUL;
+	}
+#endif
 	out_str(buf);
 	if (utf_char2cells(ScreenLinesUC[off]) > 1)
 	    ++screen_cur_col;
@@ -7543,6 +7606,11 @@
 #endif
 #ifdef FEAT_KEYMAP
 		if (State & LANGMAP)
+# ifdef FEAT_ARABIC
+		    if (p_arabic)
+		        MSG_PUTS_ATTR(_(" Arabic"), attr);
+                    else
+# endif
 		    MSG_PUTS_ATTR(_(" (lang)"), attr);
 #endif
 		if ((State & INSERT) && p_paste)
--- ./src/message.c.orig	Tue Jan 28 23:25:30 2003
+++ ./src/message.c	Wed Feb 26 13:54:01 2003
@@ -920,7 +920,11 @@
     if (!msg_scroll && full_screen)	/* overwrite last message */
     {
 	msg_row = cmdline_row;
-	msg_col = 0;
+	msg_col =
+#ifdef FEAT_ARABIC
+	  msg_rl ? Columns-1 :
+#endif
+	  0;
     }
     else if (msg_didout)		    /* start message on next line */
     {
@@ -1397,7 +1401,11 @@
 
     msg_didout = TRUE;		/* remember that line is not empty */
     cw = (*mb_ptr2cells)(s);
-    if (cw > 1 && msg_col == Columns - 1)
+    if (cw > 1 && (msg_col == Columns - 1
+#ifdef FEAT_ARABIC
+		   || (msg_rl && msg_col <= 1)
+#endif
+		   ))
     {
 	/* Doesn't fit, print a highlighted '>' to fill it up. */
 	msg_screen_putchar('>', hl_attr(HLF_AT));
@@ -1407,11 +1415,24 @@
     mch_memmove(buf, s, (size_t)l);
     buf[l] = NUL;
     screen_puts(buf, msg_row, msg_col, attr);
+#ifdef FEAT_ARABIC
+    if ( msg_rl )
+    {
+      if ((msg_col -= cw) == 0)
+	{
+	  msg_col = Columns;
+	  ++msg_row;
+	}
+    }
+    else
+#endif
+    {
     if ((msg_col += cw) >= Columns)
     {
 	msg_col = 0;
 	++msg_row;
     }
+    }
     return s + l;
 }
 #endif
@@ -1555,10 +1576,22 @@
 	    }
 
 	    /* primitive way to compute the current column */
+#ifdef FEAT_ARABIC
+	    if ( msg_rl )
+	    {
+	      if (*s == '\r' || *s == '\n')
+		  msg_col = Columns-1;
+	      else
+		--msg_col;
+	    }
+	    else
+#endif
+	    {
 	    if (*s == '\r' || *s == '\n')
 		msg_col = 0;
 	    else
 		++msg_col;
+	    }
 	    ++s;
 	}
 	msg_didout = TRUE;	    /* assume that line is not empty */
@@ -1583,12 +1616,30 @@
 	 */
 	if (msg_row >= Rows - 1
 		&& (*s == '\n'
+#ifdef FEAT_ARABIC
+		    || msg_rl &&
+		    (
+		     msg_col <= 1
+		     || (*s == TAB && msg_col <= 7)
+# ifdef FEAT_MBYTE
+		     || (has_mbyte && (*mb_ptr2cells)(s) > 1 && msg_col <= 2))
+# endif
+		    || !msg_rl &&
+		    (
+		     msg_col >= Columns - 1
+		     || (*s == TAB && msg_col >= ((Columns - 1) & ~7))
+# ifdef FEAT_MBYTE
+		     || (has_mbyte && (*mb_ptr2cells)(s) > 1
+			                            && msg_col >= Columns - 2))
+# endif
+#else
 		    || msg_col >= Columns - 1
 		    || (*s == TAB && msg_col >= ((Columns - 1) & ~7))
 #ifdef FEAT_MBYTE
 		    || (has_mbyte && (*mb_ptr2cells)(s) > 1
 						    && msg_col >= Columns - 2)
 #endif
+#endif
 			      ))
 	{
 	    /* When no more prompt an no more room, truncate here */
@@ -1774,6 +1825,12 @@
 		    msg_col = 0;
 		    return;	    /* the string is not displayed! */
 		}
+#ifdef FEAT_ARABIC
+		if (msg_rl)
+		{
+		  msg_col = Columns-1;
+		}
+#endif
 	    }
 	}
 	if (*s == '\n')		    /* go to next line */
@@ -1944,11 +2001,24 @@
 {
     msg_didout = TRUE;		/* remember that line is not empty */
     screen_putchar(c, msg_row, msg_col, attr);
+#ifdef FEAT_ARABIC
+    if ( msg_rl )
+    {
+      if (--msg_col == 0)
+      {
+	msg_col = Columns;
+	++msg_row;
+      }
+    }
+    else
+#endif
+    {
     if (++msg_col >= Columns)
     {
 	msg_col = 0;
 	++msg_row;
     }
+    }
 }
 
     void
@@ -2035,8 +2105,18 @@
     }
     else
     {
+#ifdef FEAT_ARABIC
+      if ( msg_rl )
+      {
+	screen_fill(msg_row, msg_row + 1, 0, msg_col + 1, ' ', ' ', 0);
+	screen_fill(msg_row + 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);
+      }
+    else
+#endif
+      {
 	screen_fill(msg_row, msg_row + 1, msg_col, (int)Columns, ' ', ' ', 0);
 	screen_fill(msg_row + 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);
+      }
     }
 }
 
--- ./src/search.c.orig	Tue Nov 12 14:59:35 2002
+++ ./src/search.c	Wed Feb 26 13:54:01 2003
@@ -171,7 +171,50 @@
 	add_to_history(HIST_SEARCH, pat, TRUE);
 #endif
 
+#ifdef FEAT_ARABIC
+    if ( curwin->w_p_rl )
+      {
+	int cmd_len;
+	int j, k;
+	int out_len;
+	char_u *rev_pattern;
+
+	cmd_len = (unsigned)STRLEN(pat) - 1;
+	rev_pattern = alloc((cmd_len) + 2);
+	j = 0;
+	for ((j=0, k=cmd_len); k >= 0; )
+	  {
+#ifdef FEAT_MBYTE
+	    if (has_mbyte)
+	    {
+	      if (k >= 1)
+		out_len = (*mb_ptr2len_check)(&pat[k-1]);
+	      else
+		out_len = (*mb_ptr2len_check)(&pat[k]);
+	    }
+	    else
+#endif
+	      out_len = 1;
+
+	    if ( out_len == 2 )
+	      {
+		rev_pattern[j]   = pat[k-1];
+		rev_pattern[j+1] = pat[k];
+	      }
+	    else
+	      rev_pattern[j] = pat[k];
+
+	    j = j + out_len;
+	    k = k - out_len;
+	  }
+	rev_pattern[j] = NUL;
+	mr_pattern = rev_pattern;
+      }
+    else
+#endif
+      {
     mr_pattern = pat;
+      }
 
     /*
      * Save the currently used pattern in the appropriate place,
@@ -1020,10 +1063,29 @@
 		    vim_free(trunc);
 		}
 		else
+		{
+#ifdef FEAT_ARABIC
+		    /* the search pattern when found should be shown
+		       on right in rightleft mode - ugly hack I know
+		     */
+		    msg_rl = (curwin->w_p_rl && ((msgbuf[0] == '/') || (msgbuf[0] == '?')));
+		    msg_start();
+#endif
 		    msg_outtrans(msgbuf);
+#ifdef FEAT_ARABIC
+		    redraw_msg(msgbuf+1, (STRLEN(msgbuf)-1));
+#endif
+		}
 		msg_clr_eos();
 		msg_check();
 		vim_free(msgbuf);
+#ifdef FEAT_ARABIC
+		if ( msg_rl )
+		{
+		  msg_rl = 0;
+		  msg_start();
+		}
+#endif
 
 		gotocmdline(FALSE);
 		out_flush();
--- ./src/version.c.orig	Tue Feb  4 15:51:15 2003
+++ ./src/version.c	Wed Feb 12 11:20:15 2003
@@ -60,6 +60,11 @@
 	"-ARP",
 # endif
 #endif
+#ifdef FEAT_ARABIC
+	"+arabic",
+#else
+	"-arabic",
+#endif
 #ifdef FEAT_AUTOCMD
 	"+autocmd",
 #else
--- /dev/null	Wed Feb 12 11:31:38 2003
+++ ./src/arabic.h	Wed Feb 12 18:20:15 2003
@@ -0,0 +1,258 @@
+/* $Id: arabic_shape.patch,v 1.8.2.1 2003/02/26 21:27:17 nadim Exp $
+ */
+
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * VIM - Vi IMproved    by Bram Moolenaar
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ */
+
+/*
+ * Arabic characters are catagorized into following types:
+ *
+ * Isolated     - iso-8859-6 form         char denoted with     a_*
+ * Initial      - unicode form-B start    char denoted with     a_i_*
+ * Medial       - unicode form-B middle   char denoted with     a_m_*
+ * Final        - unicode form-B final    char denoted with     a_f_*
+ * Stand-Alone  - unicode form-B isolated char denoted with     a_s_* (NOT USED)
+ *
+ * --
+ *
+ * Author: Nadim Shaikli & Isam Bayazidi
+ * - (based on Unicode)
+ *
+ */
+
+/*
+ * Arabic ISO-10646-1 character set definition
+ */
+
+/* 
+ * Arabic ISO-8859-6 (subset of 10646; 0600 - 06FF)
+ */
+#define a_COMMA                         0x060C
+#define a_SEMICOLON                     0x061B
+#define a_QUESTION                      0x061F
+#define a_HAMZA                         0x0621
+#define a_ALEF_MADDA                    0x0622
+#define a_ALEF_HAMZA_ABOVE              0x0623
+#define a_WAW_HAMZA                     0x0624
+#define a_ALEF_HAMZA_BELOW              0x0625
+#define a_YEH_HAMZA                     0x0626
+#define a_ALEF                          0x0627
+#define a_BEH                           0x0628
+#define a_TEH_MARBUTA                   0x0629
+#define a_TEH                           0x062a
+#define a_THEH                          0x062b
+#define a_JEEM                          0x062c
+#define a_HAH                           0x062d
+#define a_KHAH                          0x062e
+#define a_DAL                           0x062f
+#define a_THAL                          0x0630
+#define a_REH                           0x0631
+#define a_ZAIN                          0x0632
+#define a_SEEN                          0x0633
+#define a_SHEEN                         0x0634
+#define a_SAD                           0x0635
+#define a_DAD                           0x0636
+#define a_TAH                           0x0637
+#define a_ZAH                           0x0638
+#define a_AIN                           0x0639
+#define a_GHAIN                         0x063a
+#define a_TATWEEL                       0x0640
+#define a_FEH                           0x0641
+#define a_QAF                           0x0642
+#define a_KAF                           0x0643
+#define a_LAM                           0x0644
+#define a_MEEM                          0x0645
+#define a_NOON                          0x0646
+#define a_HEH                           0x0647
+#define a_WAW                           0x0648
+#define a_ALEF_MAKSURA                  0x0649
+#define a_YEH                           0x064a
+
+#define a_FATHATAN                      0x064b
+#define a_DAMMATAN                      0x064c
+#define a_KASRATAN                      0x064d
+#define a_FATHA                         0x064e
+#define a_DAMMA                         0x064f
+#define a_KASRA                         0x0650
+#define a_SHADDA                        0x0651
+#define a_SUKUN                         0x0652
+
+#define a_MADDA_ABOVE                   0x0653
+#define a_HAMZA_ABOVE                   0x0654
+#define a_HAMZA_BELOW                   0x0655
+
+#define a_ZERO                          0x0660
+#define a_ONE                           0x0661
+#define a_TWO                           0x0662
+#define a_THREE                         0x0663
+#define a_FOUR                          0x0664
+#define a_FIVE                          0x0665
+#define a_SIX                           0x0666
+#define a_SEVEN                         0x0667
+#define a_EIGHT                         0x0668
+#define a_NINE                          0x0669
+#define a_PERCENT                       0x066a
+#define a_DECIMAL                       0x066b
+#define a_THOUSANDS                     0x066c
+#define a_STAR                          0x066d
+#define a_MINI_ALEF                     0x0670
+/* Rest of 8859-6 does not relate to Arabic */
+            
+/* 
+ * Arabic Presentation Form-B (subset of 10646; FE70 - FEFF)
+ *
+ *  s -> isolated
+ *  i -> initial
+ *  m -> medial
+ *  f -> final
+ *
+ */
+#define a_s_FATHATAN                    0xfe70
+#define a_m_TATWEEL_FATHATAN            0xfe71
+#define a_s_DAMMATAN                    0xfe72
+
+#define a_s_KASRATAN                    0xfe74
+
+#define a_s_FATHA                       0xfe76
+#define a_m_FATHA                       0xfe77
+#define a_s_DAMMA                       0xfe78
+#define a_m_DAMMA                       0xfe79
+#define a_s_KASRA                       0xfe7a
+#define a_m_KASRA                       0xfe7b
+#define a_s_SHADDA                      0xfe7c
+#define a_m_SHADDA                      0xfe7d
+#define a_s_SUKUN                       0xfe7e
+#define a_m_SUKUN                       0xfe7f
+
+#define a_s_HAMZA                       0xfe80
+#define a_s_ALEF_MADDA                  0xfe81
+#define a_f_ALEF_MADDA                  0xfe82
+#define a_s_ALEF_HAMZA_ABOVE            0xfe83
+#define a_f_ALEF_HAMZA_ABOVE            0xfe84
+#define a_s_WAW_HAMZA                   0xfe85
+#define a_f_WAW_HAMZA                   0xfe86
+#define a_s_ALEF_HAMZA_BELOW            0xfe87
+#define a_f_ALEF_HAMZA_BELOW            0xfe88
+#define a_s_YEH_HAMZA                   0xfe89
+#define a_f_YEH_HAMZA                   0xfe8a
+#define a_i_YEH_HAMZA                   0xfe8b
+#define a_m_YEH_HAMZA                   0xfe8c
+#define a_s_ALEF                        0xfe8d
+#define a_f_ALEF                        0xfe8e
+#define a_s_BEH                         0xfe8f
+#define a_f_BEH                         0xfe90
+#define a_i_BEH                         0xfe91
+#define a_m_BEH                         0xfe92
+#define a_s_TEH_MARBUTA                 0xfe93
+#define a_f_TEH_MARBUTA                 0xfe94
+#define a_s_TEH                         0xfe95
+#define a_f_TEH                         0xfe96
+#define a_i_TEH                         0xfe97
+#define a_m_TEH                         0xfe98
+#define a_s_THEH                        0xfe99
+#define a_f_THEH                        0xfe9a
+#define a_i_THEH                        0xfe9b
+#define a_m_THEH                        0xfe9c
+#define a_s_JEEM                        0xfe9d
+#define a_f_JEEM                        0xfe9e
+#define a_i_JEEM                        0xfe9f
+#define a_m_JEEM                        0xfea0
+#define a_s_HAH                         0xfea1
+#define a_f_HAH                         0xfea2
+#define a_i_HAH                         0xfea3
+#define a_m_HAH                         0xfea4
+#define a_s_KHAH                        0xfea5
+#define a_f_KHAH                        0xfea6
+#define a_i_KHAH                        0xfea7
+#define a_m_KHAH                        0xfea8
+#define a_s_DAL                         0xfea9
+#define a_f_DAL                         0xfeaa
+#define a_s_THAL                        0xfeab
+#define a_f_THAL                        0xfeac
+#define a_s_REH                         0xfead
+#define a_f_REH                         0xfeae
+#define a_s_ZAIN                        0xfeaf
+#define a_f_ZAIN                        0xfeb0
+#define a_s_SEEN                        0xfeb1
+#define a_f_SEEN                        0xfeb2
+#define a_i_SEEN                        0xfeb3
+#define a_m_SEEN                        0xfeb4
+#define a_s_SHEEN                       0xfeb5
+#define a_f_SHEEN                       0xfeb6
+#define a_i_SHEEN                       0xfeb7
+#define a_m_SHEEN                       0xfeb8
+#define a_s_SAD                         0xfeb9
+#define a_f_SAD                         0xfeba
+#define a_i_SAD                         0xfebb
+#define a_m_SAD                         0xfebc
+#define a_s_DAD                         0xfebd
+#define a_f_DAD                         0xfebe
+#define a_i_DAD                         0xfebf
+#define a_m_DAD                         0xfec0
+#define a_s_TAH                         0xfec1
+#define a_f_TAH                         0xfec2
+#define a_i_TAH                         0xfec3
+#define a_m_TAH                         0xfec4
+#define a_s_ZAH                         0xfec5
+#define a_f_ZAH                         0xfec6
+#define a_i_ZAH                         0xfec7
+#define a_m_ZAH                         0xfec8
+#define a_s_AIN                         0xfec9
+#define a_f_AIN                         0xfeca
+#define a_i_AIN                         0xfecb
+#define a_m_AIN                         0xfecc
+#define a_s_GHAIN                       0xfecd
+#define a_f_GHAIN                       0xfece
+#define a_i_GHAIN                       0xfecf
+#define a_m_GHAIN                       0xfed0
+#define a_s_FEH                         0xfed1
+#define a_f_FEH                         0xfed2
+#define a_i_FEH                         0xfed3
+#define a_m_FEH                         0xfed4
+#define a_s_QAF                         0xfed5
+#define a_f_QAF                         0xfed6
+#define a_i_QAF                         0xfed7
+#define a_m_QAF                         0xfed8
+#define a_s_KAF                         0xfed9
+#define a_f_KAF                         0xfeda
+#define a_i_KAF                         0xfedb
+#define a_m_KAF                         0xfedc
+#define a_s_LAM                         0xfedd
+#define a_f_LAM                         0xfede
+#define a_i_LAM                         0xfedf
+#define a_m_LAM                         0xfee0
+#define a_s_MEEM                        0xfee1
+#define a_f_MEEM                        0xfee2
+#define a_i_MEEM                        0xfee3
+#define a_m_MEEM                        0xfee4
+#define a_s_NOON                        0xfee5
+#define a_f_NOON                        0xfee6
+#define a_i_NOON                        0xfee7
+#define a_m_NOON                        0xfee8
+#define a_s_HEH                         0xfee9
+#define a_f_HEH                         0xfeea
+#define a_i_HEH                         0xfeeb
+#define a_m_HEH                         0xfeec
+#define a_s_WAW                         0xfeed
+#define a_f_WAW                         0xfeee
+#define a_s_ALEF_MAKSURA                0xfeef
+#define a_f_ALEF_MAKSURA                0xfef0
+#define a_s_YEH                         0xfef1
+#define a_f_YEH                         0xfef2
+#define a_i_YEH                         0xfef3
+#define a_m_YEH                         0xfef4
+#define a_s_LAM_ALEF_MADDA_ABOVE        0xfef5
+#define a_f_LAM_ALEF_MADDA_ABOVE        0xfef6
+#define a_s_LAM_ALEF_HAMZA_ABOVE        0xfef7
+#define a_f_LAM_ALEF_HAMZA_ABOVE        0xfef8
+#define a_s_LAM_ALEF_HAMZA_BELOW        0xfef9
+#define a_f_LAM_ALEF_HAMZA_BELOW        0xfefa
+#define a_s_LAM_ALEF                    0xfefb
+#define a_f_LAM_ALEF                    0xfefc
+
+#define a_BYTE_ORDER_MARK               0xfeff
--- /dev/null	Wed Feb 12 11:31:38 2003
+++ ./src/arabic.c	Wed Feb 12 18:20:15 2003
@@ -0,0 +1,1336 @@
+/* $Id: arabic_shape.patch,v 1.8.2.1 2003/02/26 21:27:17 nadim Exp $
+ */
+
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * VIM - Vi IMproved    by Bram Moolenaar
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ * See README.txt for an overview of the Vim source code.
+ */
+
+/*
+ * arabic.c: functions for Arabic language
+ *
+ * Included by main.c, when FEAT_ARABIC & FEAT_GUI is defined.
+ *
+ * --
+ *
+ * Author: Nadim Shaikli & Isam Bayazidi
+ *
+ */
+
+static int  A_is_a __ARGS((int cur_c));
+static int  A_is_s __ARGS((int cur_c));
+static int  A_is_f __ARGS((int cur_c));
+static int  chg_c_a2s __ARGS((int cur_c));
+static int  chg_c_a2i __ARGS((int cur_c));
+static int  chg_c_a2m __ARGS((int cur_c));
+static int  chg_c_a2f __ARGS((int cur_c));
+static int  chg_c_i2m __ARGS((int cur_c));
+static int  chg_c_f2m __ARGS((int cur_c));
+static int  chg_c_laa2i __ARGS((int hid_c));
+static int  chg_c_laa2f __ARGS((int hid_c));
+static void A_redo_shape __ARGS((int loc, int cur_c));
+static int  A_firstc_laa __ARGS((int offset, int c));
+static int  A_is_harakat __ARGS((int c));
+static int  A_is_iso __ARGS((int c));
+static int  A_is_formb __ARGS((int c));
+static int  A_is_ok __ARGS((int c));
+static int  A_is_valid __ARGS((int c));
+static int  A_is_special __ARGS((int c));
+
+/* NOTE: line and debug code needs removal upon release */
+EXTERN int arab_debug = 0;
+
+
+/*
+ * Returns True if c is an ISO-8859-6 shaped ARABIC letter (user entered)
+ *
+ */
+ 
+  static int
+A_is_a(cur_c)
+     int cur_c;
+{
+  if ( arab_debug )
+    fprintf(stderr,"arabic.c - inside A_is_a - 0x%x\n", cur_c);
+
+  switch (cur_c)
+    {
+    case a_HAMZA:
+    case a_ALEF_MADDA:
+    case a_ALEF_HAMZA_ABOVE:
+    case a_WAW_HAMZA:
+    case a_ALEF_HAMZA_BELOW:
+    case a_YEH_HAMZA:
+    case a_ALEF:
+    case a_BEH:
+    case a_TEH_MARBUTA:
+    case a_TEH:
+    case a_THEH:
+    case a_JEEM:
+    case a_HAH:
+    case a_KHAH:
+    case a_DAL:
+    case a_THAL:
+    case a_REH:
+    case a_ZAIN:
+    case a_SEEN:
+    case a_SHEEN:
+    case a_SAD:
+    case a_DAD:
+    case a_TAH:
+    case a_ZAH:
+    case a_AIN:
+    case a_GHAIN:
+    case a_TATWEEL:
+    case a_FEH:
+    case a_QAF:
+    case a_KAF:
+    case a_LAM:
+    case a_MEEM:
+    case a_NOON:
+    case a_HEH:
+    case a_WAW:
+    case a_ALEF_MAKSURA:
+    case a_YEH:
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
+
+/*
+ * Returns True if c is an Isolated Form-B ARABIC letter
+ *
+ */
+ 
+  static int
+A_is_s(cur_c)
+     int cur_c;
+{
+  if ( arab_debug )
+    fprintf(stderr,"arabic.c - inside A_is_s - 0x%x\n", cur_c);
+
+  switch (cur_c)
+    {
+    case a_s_HAMZA:
+    case a_s_ALEF_MADDA:
+    case a_s_ALEF_HAMZA_ABOVE:
+    case a_s_WAW_HAMZA:
+    case a_s_ALEF_HAMZA_BELOW:
+    case a_s_YEH_HAMZA:
+    case a_s_ALEF:
+    case a_s_BEH:
+    case a_s_TEH_MARBUTA:
+    case a_s_TEH:
+    case a_s_THEH:
+    case a_s_JEEM:
+    case a_s_HAH:
+    case a_s_KHAH:
+    case a_s_DAL:
+    case a_s_THAL:
+    case a_s_REH:
+    case a_s_ZAIN:
+    case a_s_SEEN:
+    case a_s_SHEEN:
+    case a_s_SAD:
+    case a_s_DAD:
+    case a_s_TAH:
+    case a_s_ZAH:
+    case a_s_AIN:
+    case a_s_GHAIN:
+    case a_s_FEH:
+    case a_s_QAF:
+    case a_s_KAF:
+    case a_s_LAM:
+    case a_s_MEEM:
+    case a_s_NOON:
+    case a_s_HEH:
+    case a_s_WAW:
+    case a_s_ALEF_MAKSURA:
+    case a_s_YEH:
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
+
+/*
+ * Returns True if c is a Final shape of an ARABIC letter
+ *
+ */
+ 
+  static int
+A_is_f(cur_c)
+     int cur_c;
+{
+  if ( arab_debug )
+    fprintf(stderr,"arabic.c - inside A_is_f - 0x%x\n", cur_c);
+
+  switch(cur_c)
+    {
+    case a_f_ALEF_MADDA:
+    case a_f_ALEF_HAMZA_ABOVE:
+    case a_f_WAW_HAMZA:
+    case a_f_ALEF_HAMZA_BELOW:
+    case a_f_YEH_HAMZA:
+    case a_f_ALEF:
+    case a_f_BEH:
+    case a_f_TEH_MARBUTA:
+    case a_f_TEH:
+    case a_f_THEH:
+    case a_f_JEEM:
+    case a_f_HAH:
+    case a_f_KHAH:
+    case a_f_DAL:
+    case a_f_THAL:
+    case a_f_REH:
+    case a_f_ZAIN:
+    case a_f_SEEN:
+    case a_f_SHEEN:
+    case a_f_SAD:
+    case a_f_DAD:
+    case a_f_TAH:
+    case a_f_ZAH:
+    case a_f_AIN:
+    case a_f_GHAIN:
+    case a_f_FEH:
+    case a_f_QAF:
+    case a_f_KAF:
+    case a_f_LAM:
+    case a_f_MEEM:
+    case a_f_NOON:
+    case a_f_HEH:
+    case a_f_WAW:
+    case a_f_ALEF_MAKSURA:
+    case a_f_YEH:
+    case a_f_LAM_ALEF_MADDA_ABOVE:
+    case a_f_LAM_ALEF_HAMZA_ABOVE:
+    case a_f_LAM_ALEF_HAMZA_BELOW:
+    case a_f_LAM_ALEF:
+      return TRUE;
+    }
+  return FALSE;
+}
+
+
+/*
+ * Change shape - from ISO-8859-6/Isolated to Form-B Isolated
+ *
+ */
+ 
+  static int
+chg_c_a2s(cur_c)
+     int cur_c;
+{
+  int tempc;
+    
+  if ( arab_debug )
+    fprintf(stderr,"arabic.c - inside chg_c_a2s - 0x%x\n", cur_c);
+
+  switch (cur_c)
+    {
+    case a_HAMZA:
+      tempc = a_s_HAMZA;
+      break;
+    case a_ALEF_MADDA:
+      tempc = a_s_ALEF_MADDA;
+      break;
+    case a_ALEF_HAMZA_ABOVE:
+      tempc = a_s_ALEF_HAMZA_ABOVE;
+      break;
+    case a_WAW_HAMZA:
+      tempc = a_s_WAW_HAMZA;
+      break;
+    case a_ALEF_HAMZA_BELOW:
+      tempc = a_s_ALEF_HAMZA_BELOW;
+      break;
+    case a_YEH_HAMZA:
+      tempc = a_s_YEH_HAMZA;
+      break;
+    case a_ALEF:
+      tempc = a_s_ALEF;
+      break;
+    case a_TEH_MARBUTA:
+      tempc = a_s_TEH_MARBUTA;
+      break;
+    case a_DAL:
+      tempc = a_s_DAL;
+      break;
+    case a_THAL:
+      tempc = a_s_THAL;
+      break;
+    case a_REH:
+      tempc = a_s_REH;
+      break;
+    case a_ZAIN:
+      tempc = a_s_ZAIN;
+      break;
+    case a_TATWEEL:                     /* exceptions */
+      tempc = cur_c;
+      break;
+    case a_WAW:
+      tempc = a_s_WAW;
+      break;
+    case a_ALEF_MAKSURA:
+      tempc = a_s_ALEF_MAKSURA;
+      break;
+    case a_BEH:
+      tempc = a_s_BEH;
+      break;
+    case a_TEH:
+      tempc = a_s_TEH;
+      break;
+    case a_THEH:
+      tempc = a_s_THEH;
+      break;
+    case a_JEEM:
+      tempc = a_s_JEEM;
+      break;
+    case a_HAH:
+      tempc = a_s_HAH;
+      break;
+    case a_KHAH:
+      tempc = a_s_KHAH;
+      break;
+    case a_SEEN:
+      tempc = a_s_SEEN;
+      break;
+    case a_SHEEN:
+      tempc = a_s_SHEEN;
+      break;
+    case a_SAD:
+      tempc = a_s_SAD;
+      break;
+    case a_DAD:
+      tempc = a_s_DAD;
+      break;
+    case a_TAH:
+      tempc = a_s_TAH;
+      break;
+    case a_ZAH:
+      tempc = a_s_ZAH;
+      break;
+    case a_AIN:
+      tempc = a_s_AIN;
+      break;
+    case a_GHAIN:
+      tempc = a_s_GHAIN;
+      break;
+    case a_FEH:
+      tempc = a_s_FEH;
+      break;
+    case a_QAF:
+      tempc = a_s_QAF;
+      break;
+    case a_KAF:
+      tempc = a_s_KAF;
+      break;
+    case a_LAM:
+      tempc = a_s_LAM;
+      break;
+    case a_MEEM:
+      tempc = a_s_MEEM;
+      break;
+    case a_NOON:
+      tempc = a_s_NOON;
+      break;
+    case a_HEH:
+      tempc = a_s_HEH;
+      break;
+    case a_YEH:
+      tempc = a_s_YEH;
+      break;
+    default:
+      tempc = 0;
+    }
+
+  return (tempc);
+}
+
+
+/*
+ * Change shape - from ISO-8859-6/Isolated to Initial
+ *
+ */
+ 
+  static int
+chg_c_a2i(cur_c)
+     int cur_c;
+{
+  int tempc;
+    
+  if ( arab_debug )
+    fprintf(stderr,"arabic.c - inside chg_c_a2i - 0x%x\n", cur_c);
+
+  switch (cur_c)
+    {
+    case a_YEH_HAMZA:
+      tempc = a_i_YEH_HAMZA;
+      break;
+    case a_HAMZA:                       /* exceptions */
+      tempc = a_s_HAMZA;
+      break;
+    case a_ALEF_MADDA:                  /* exceptions */
+      tempc = a_s_ALEF_MADDA;
+      break;
+    case a_ALEF_HAMZA_ABOVE:            /* exceptions */
+      tempc = a_s_ALEF_HAMZA_ABOVE;
+      break;
+    case a_WAW_HAMZA:                   /* exceptions */
+      tempc = a_s_WAW_HAMZA;
+      break;
+    case a_ALEF_HAMZA_BELOW:            /* exceptions */
+      tempc = a_s_ALEF_HAMZA_BELOW;
+      break;
+    case a_ALEF:                        /* exceptions */
+      tempc = a_s_ALEF;
+      break;
+    case a_TEH_MARBUTA:                 /* exceptions */
+      tempc = a_s_TEH_MARBUTA;
+      break;
+    case a_DAL:                         /* exceptions */
+      tempc = a_s_DAL;
+      break;
+    case a_THAL:                        /* exceptions */
+      tempc = a_s_THAL;
+      break;
+    case a_REH:                         /* exceptions */
+      tempc = a_s_REH;
+      break;
+    case a_ZAIN:                        /* exceptions */
+      tempc = a_s_ZAIN;
+      break;
+    case a_TATWEEL:                     /* exceptions */
+      tempc = cur_c;
+      break;
+    case a_WAW:                         /* exceptions */
+      tempc = a_s_WAW;
+      break;
+    case a_ALEF_MAKSURA:                /* exceptions */
+      tempc = a_s_ALEF_MAKSURA;
+      break;
+    case a_BEH:
+      tempc = a_i_BEH;
+      break;
+    case a_TEH:
+      tempc = a_i_TEH;
+      break;
+    case a_THEH:
+      tempc = a_i_THEH;
+      break;
+    case a_JEEM:
+      tempc = a_i_JEEM;
+      break;
+    case a_HAH:
+      tempc = a_i_HAH;
+      break;
+    case a_KHAH:
+      tempc = a_i_KHAH;
+      break;
+    case a_SEEN:
+      tempc = a_i_SEEN;
+      break;
+    case a_SHEEN:
+      tempc = a_i_SHEEN;
+      break;
+    case a_SAD:
+      tempc = a_i_SAD;
+      break;
+    case a_DAD:
+      tempc = a_i_DAD;
+      break;
+    case a_TAH:
+      tempc = a_i_TAH;
+      break;
+    case a_ZAH:
+      tempc = a_i_ZAH;
+      break;
+    case a_AIN:
+      tempc = a_i_AIN;
+      break;
+    case a_GHAIN:
+      tempc = a_i_GHAIN;
+      break;
+    case a_FEH:
+      tempc = a_i_FEH;
+      break;
+    case a_QAF:
+      tempc = a_i_QAF;
+      break;
+    case a_KAF:
+      tempc = a_i_KAF;
+      break;
+    case a_LAM:
+      tempc = a_i_LAM;
+      break;
+    case a_MEEM:
+      tempc = a_i_MEEM;
+      break;
+    case a_NOON:
+      tempc = a_i_NOON;
+      break;
+    case a_HEH:
+      tempc = a_i_HEH;
+      break;
+    case a_YEH:
+      tempc = a_i_YEH;
+      break;
+    default:
+      tempc = 0;
+    }
+
+  return (tempc);
+}
+
+
+/*
+ * Change shape - from ISO-8859-6/Isolated to Medial
+ *
+ */
+ 
+  static int
+chg_c_a2m(cur_c)
+     int cur_c;
+{
+  int tempc;
+    
+  if ( arab_debug )
+    fprintf(stderr,"arabic.c - inside chg_c_a2m - 0x%x\n", cur_c);
+
+  switch (cur_c)
+    {
+    case a_HAMZA:                       /* exception */
+      tempc = a_s_HAMZA;
+      break;
+    case a_ALEF_MADDA:                  /* exception */
+      tempc = a_f_ALEF_MADDA;
+      break;
+    case a_ALEF_HAMZA_ABOVE:            /* exception */
+      tempc = a_f_ALEF_HAMZA_ABOVE;
+      break;
+    case a_WAW_HAMZA:                   /* exception */
+      tempc = a_f_WAW_HAMZA;
+      break;
+    case a_ALEF_HAMZA_BELOW:            /* exception */
+      tempc = a_f_ALEF_HAMZA_BELOW;
+      break;
+    case a_YEH_HAMZA:
+      tempc = a_m_YEH_HAMZA;
+      break;
+    case a_ALEF:                        /* exception */
+      tempc = a_f_ALEF;
+      break;
+    case a_BEH:
+      tempc = a_m_BEH;
+      break;
+    case a_TEH_MARBUTA:                 /* exception */
+      tempc = a_f_TEH_MARBUTA;
+      break;
+    case a_TEH:
+      tempc = a_m_TEH;
+      break;
+    case a_THEH:
+      tempc = a_m_THEH;
+      break;
+    case a_JEEM:
+      tempc = a_m_JEEM;
+      break;
+    case a_HAH:
+      tempc = a_m_HAH;
+      break;
+    case a_KHAH:
+      tempc = a_m_KHAH;
+      break;
+    case a_DAL:                         /* exception */
+      tempc = a_f_DAL;
+      break;
+    case a_THAL:                        /* exception */
+      tempc = a_f_THAL;
+      break;
+    case a_REH:                         /* exception */
+      tempc = a_f_REH;
+      break;
+    case a_ZAIN:                        /* exception */
+      tempc = a_f_ZAIN;
+      break;
+    case a_SEEN:
+      tempc = a_m_SEEN;
+      break;
+    case a_SHEEN:
+      tempc = a_m_SHEEN;
+      break;
+    case a_SAD:
+      tempc = a_m_SAD;
+      break;
+    case a_DAD:
+      tempc = a_m_DAD;
+      break;
+    case a_TAH:
+      tempc = a_m_TAH;
+      break;
+    case a_ZAH:
+      tempc = a_m_ZAH;
+      break;
+    case a_AIN:
+      tempc = a_m_AIN;
+      break;
+    case a_GHAIN:
+      tempc = a_m_GHAIN;
+      break;
+    case a_TATWEEL:                     /* exception */
+      tempc = cur_c;
+      break;
+    case a_FEH:
+      tempc = a_m_FEH;
+      break;
+    case a_QAF:
+      tempc = a_m_QAF;
+      break;
+    case a_KAF:
+      tempc = a_m_KAF;
+      break;
+    case a_LAM:
+      tempc = a_m_LAM;
+      break;
+    case a_MEEM:
+      tempc = a_m_MEEM;
+      break;
+    case a_NOON:
+      tempc = a_m_NOON;
+      break;
+    case a_HEH:
+      tempc = a_m_HEH;
+      break;
+    case a_WAW:                         /* exception */
+      tempc = a_f_WAW;
+      break;
+    case a_ALEF_MAKSURA:                /* exception */
+      tempc = a_f_ALEF_MAKSURA;
+      break;
+    case a_YEH:
+      tempc = a_m_YEH;
+      break;
+    default:
+      tempc = 0;
+    }
+
+  return (tempc);
+}
+
+
+/*
+ * Change shape - from ISO-8859-6/Isolated to final
+ *
+ */
+ 
+  static int
+chg_c_a2f(cur_c)
+     int cur_c;
+{
+  int tempc;
+    
+/* NOTE: these encodings need to be accounted for
+
+  a_f_ALEF_MADDA;
+  a_f_ALEF_HAMZA_ABOVE;
+  a_f_ALEF_HAMZA_BELOW;
+  a_f_LAM_ALEF_MADDA_ABOVE;
+  a_f_LAM_ALEF_HAMZA_ABOVE;
+  a_f_LAM_ALEF_HAMZA_BELOW;
+*/
+
+  if ( arab_debug )
+    fprintf(stderr,"arabic.c - inside chg_c_a2f - 0x%x\n", cur_c);
+
+  switch (cur_c)
+    {
+    case a_HAMZA:                       /* exception */
+      tempc = a_s_HAMZA;
+      break;
+    case a_ALEF_MADDA:
+      tempc = a_f_ALEF_MADDA;
+      break;
+    case a_ALEF_HAMZA_ABOVE:
+      tempc = a_f_ALEF_HAMZA_ABOVE;
+      break;
+    case a_WAW_HAMZA:
+      tempc = a_f_WAW_HAMZA;
+      break;
+    case a_ALEF_HAMZA_BELOW:
+      tempc = a_f_ALEF_HAMZA_BELOW;
+      break;
+    case a_YEH_HAMZA:
+      tempc = a_f_YEH_HAMZA;
+      break;
+    case a_ALEF:
+      tempc = a_f_ALEF;
+      break;
+    case a_BEH:
+      tempc = a_f_BEH;
+      break;
+    case a_TEH_MARBUTA:
+      tempc = a_f_TEH_MARBUTA;
+      break;
+    case a_TEH:
+      tempc = a_f_TEH;
+      break;
+    case a_THEH:
+      tempc = a_f_THEH;
+      break;
+    case a_JEEM:
+      tempc = a_f_JEEM;
+      break;
+    case a_HAH:
+      tempc = a_f_HAH;
+      break;
+    case a_KHAH:
+      tempc = a_f_KHAH;
+      break;
+    case a_DAL:
+      tempc = a_f_DAL;
+      break;
+    case a_THAL:
+      tempc = a_f_THAL;
+      break;
+    case a_REH:
+      tempc = a_f_REH;
+      break;
+    case a_ZAIN:
+      tempc = a_f_ZAIN;
+      break;
+    case a_SEEN:
+      tempc = a_f_SEEN;
+      break;
+    case a_SHEEN:
+      tempc = a_f_SHEEN;
+      break;
+    case a_SAD:
+      tempc = a_f_SAD;
+      break;
+    case a_DAD:
+      tempc = a_f_DAD;
+      break;
+    case a_TAH:
+      tempc = a_f_TAH;
+      break;
+    case a_ZAH:
+      tempc = a_f_ZAH;
+      break;
+    case a_AIN:
+      tempc = a_f_AIN;
+      break;
+    case a_GHAIN:
+      tempc = a_f_GHAIN;
+      break;
+    case a_TATWEEL:                     /* exception */
+      tempc = cur_c;
+      break; 
+    case a_FEH:
+      tempc = a_f_FEH;
+      break;
+    case a_QAF:
+      tempc = a_f_QAF;
+      break;
+    case a_KAF:
+      tempc = a_f_KAF;
+      break;
+    case a_LAM:
+      tempc = a_f_LAM;
+      break;
+    case a_MEEM:
+      tempc = a_f_MEEM;
+      break;
+    case a_NOON:
+      tempc = a_f_NOON;
+      break;
+    case a_HEH:
+      tempc = a_f_HEH;
+      break;
+    case a_WAW:
+      tempc = a_f_WAW;
+      break;
+    case a_ALEF_MAKSURA:
+      tempc = a_f_ALEF_MAKSURA;
+      break;
+    case a_YEH:
+      tempc = a_f_YEH;
+      break;
+    default:
+      tempc = 0;
+    }
+
+  return (tempc);
+}
+
+
+/*
+ * Change shape - from Initial to Medial
+ *
+ */
+ 
+  static int
+chg_c_i2m(cur_c)
+     int cur_c;
+{
+  int tempc;
+    
+  if ( arab_debug )
+    fprintf(stderr,"arabic.c - inside chg_c_i2m - 0x%x\n", cur_c);
+
+  switch (cur_c)
+    {
+    case a_i_YEH_HAMZA:
+      tempc = a_m_YEH_HAMZA;
+      break;
+    case a_i_BEH:
+      tempc = a_m_BEH;
+      break;
+    case a_i_TEH:
+      tempc = a_m_TEH;
+      break;
+    case a_i_THEH:
+      tempc = a_m_THEH;
+      break;
+    case a_i_JEEM:
+      tempc = a_m_JEEM;
+      break;
+    case a_i_HAH:
+      tempc = a_m_HAH;
+      break;
+    case a_i_KHAH:
+      tempc = a_m_KHAH;
+      break;
+    case a_i_SEEN:
+      tempc = a_m_SEEN;
+      break;
+    case a_i_SHEEN:
+      tempc = a_m_SHEEN;
+      break;
+    case a_i_SAD:
+      tempc = a_m_SAD;
+      break;
+    case a_i_DAD:
+      tempc = a_m_DAD;
+      break;
+    case a_i_TAH:
+      tempc = a_m_TAH;
+      break;
+    case a_i_ZAH:
+      tempc = a_m_ZAH;
+      break;
+    case a_i_AIN:
+      tempc = a_m_AIN;
+      break;
+    case a_i_GHAIN:
+      tempc = a_m_GHAIN;
+      break;
+    case a_i_FEH:
+      tempc = a_m_FEH;
+      break;
+    case a_i_QAF:
+      tempc = a_m_QAF;
+      break;
+    case a_i_KAF:
+      tempc = a_m_KAF;
+      break;
+    case a_i_LAM:
+      tempc = a_m_LAM;
+      break;
+    case a_i_MEEM:
+      tempc = a_m_MEEM;
+      break;
+    case a_i_NOON:
+      tempc = a_m_NOON;
+      break;
+    case a_i_HEH:
+      tempc = a_m_HEH;
+      break;
+    case a_i_YEH:
+      tempc = a_m_YEH;
+      break;
+    default:
+      tempc = 0;
+    }
+
+  return (tempc);
+}
+
+
+/*
+ * Change shape - from Final to Medial
+ *
+ */
+ 
+  static int
+chg_c_f2m(cur_c)
+     int cur_c;
+{
+  int tempc;
+
+  if ( arab_debug )
+    fprintf(stderr,"arabic.c - inside chg_c_f2m - 0x%x\n", cur_c);
+
+  switch (cur_c)
+    {
+/* NOTE: these encodings are multi-positional, no ?
+    case a_f_ALEF_MADDA:
+    case a_f_ALEF_HAMZA_ABOVE:
+    case a_f_ALEF_HAMZA_BELOW:
+ */
+    case a_f_YEH_HAMZA:
+      tempc = a_m_YEH_HAMZA;
+      break;
+    case a_f_WAW_HAMZA:                 /* exceptions */
+    case a_f_ALEF:
+    case a_f_TEH_MARBUTA:
+    case a_f_DAL:
+    case a_f_THAL:
+    case a_f_REH:
+    case a_f_ZAIN:
+    case a_f_WAW:
+    case a_f_ALEF_MAKSURA:
+      tempc = cur_c;
+      break;
+    case a_f_BEH:
+      tempc = a_m_BEH;
+      break;
+    case a_f_TEH:
+      tempc = a_m_TEH;
+      break;
+    case a_f_THEH:
+      tempc = a_m_THEH;
+      break;
+    case a_f_JEEM:
+      tempc = a_m_JEEM;
+      break;
+    case a_f_HAH:
+      tempc = a_m_HAH;
+      break;
+    case a_f_KHAH:
+      tempc = a_m_KHAH;
+      break;
+    case a_f_SEEN:
+      tempc = a_m_SEEN;
+      break;
+    case a_f_SHEEN:
+      tempc = a_m_SHEEN;
+      break;
+    case a_f_SAD:
+      tempc = a_m_SAD;
+      break;
+    case a_f_DAD:
+      tempc = a_m_DAD;
+      break;
+    case a_f_TAH:
+      tempc = a_m_TAH;
+      break;
+    case a_f_ZAH:
+      tempc = a_m_ZAH;
+      break;
+    case a_f_AIN:
+      tempc = a_m_AIN;
+      break;
+    case a_f_GHAIN:
+      tempc = a_m_GHAIN;
+      break;
+    case a_f_FEH:
+      tempc = a_m_FEH;
+      break;
+    case a_f_QAF:
+      tempc = a_m_QAF;
+      break;
+    case a_f_KAF:
+      tempc = a_m_KAF;
+      break;
+    case a_f_LAM:
+      tempc = a_m_LAM;
+      break;
+    case a_f_MEEM:
+      tempc = a_m_MEEM;
+      break;
+    case a_f_NOON:
+      tempc = a_m_NOON;
+      break;
+    case a_f_HEH:
+      tempc = a_m_HEH;
+      break;
+    case a_f_YEH:
+      tempc = a_m_YEH;
+      break;
+/* NOTE: these encodings are multi-positional, no ?
+    case a_f_LAM_ALEF_MADDA_ABOVE:
+    case a_f_LAM_ALEF_HAMZA_ABOVE:
+    case a_f_LAM_ALEF_HAMZA_BELOW:
+    case a_f_LAM_ALEF:
+ */
+    default:
+      tempc = 0;
+    }
+
+  return (tempc);
+}
+
+
+/*
+ * Change shape - from Combination (2 char) to an Isolated
+ *
+ */
+ 
+  static int
+chg_c_laa2i(hid_c)
+     int hid_c;
+{
+  int tempc;
+    
+  if ( arab_debug )
+    fprintf(stderr,"arabic.c - inside chg_c_laa2i - 0x%x\n", hid_c);
+
+  switch (hid_c)
+    {
+    case a_ALEF_MADDA:
+      tempc = a_s_LAM_ALEF_MADDA_ABOVE;
+      break;
+    case a_ALEF_HAMZA_ABOVE:
+      tempc = a_s_LAM_ALEF_HAMZA_ABOVE;
+      break;
+    case a_ALEF_HAMZA_BELOW:
+      tempc = a_s_LAM_ALEF_HAMZA_BELOW;
+      break;
+    case a_ALEF:
+      tempc = a_s_LAM_ALEF;
+      break;
+    default:
+      tempc = 0;
+    }
+
+  return (tempc);
+}
+
+
+/*
+ * Change shape - from Combination-Isolated to Final
+ *
+ */
+ 
+  static int
+chg_c_laa2f(hid_c)
+     int hid_c;
+{
+  int tempc;
+    
+  if ( arab_debug )
+    fprintf(stderr,"arabic.c - inside chg_c_laa2f - 0x%x\n", hid_c);
+
+  switch (hid_c)
+    {
+    case a_ALEF_MADDA:
+      tempc = a_f_LAM_ALEF_MADDA_ABOVE;
+      break;
+    case a_ALEF_HAMZA_ABOVE:
+      tempc = a_f_LAM_ALEF_HAMZA_ABOVE;
+      break;
+    case a_ALEF_HAMZA_BELOW:
+      tempc = a_f_LAM_ALEF_HAMZA_BELOW;
+      break;
+    case a_ALEF:
+      tempc = a_f_LAM_ALEF;
+      break;
+    default:
+      tempc = 0;
+    }
+
+  return (tempc);
+}
+
+
+/*
+ * Redo the contents of what's displayed
+ *
+ */
+ 
+  static void
+A_redo_shape(loc, cur_c)
+     int loc;
+     int cur_c;
+{
+  char_u        buf[MB_MAXBYTES + 1];
+
+  if ( arab_debug )
+    fprintf(stderr,"arabic.c - inside A_redo_shape, 0x%x\n", cur_c);
+
+  /* Store actual unicode encoding */
+  ScreenLinesUC[loc] = cur_c;
+
+  /* Specify first byte of a multi-byte char */
+  (*mb_char2bytes)(cur_c, buf);
+
+  ScreenLines[loc] = buf[0];
+}
+
+
+/*
+ * All the calls for the shaping functions go here.
+ *
+ */
+ 
+  int
+shape_arabic(offset, c)
+     int offset;
+     int c;
+{
+  int           off_prev;
+  int           off_next;
+  int           curr_c;
+  int           prev_c;
+  int           next_c;
+  int           shape_c;
+  int           c1 = 0;
+  int           c2 = 0;
+  char_u        fub[MB_MAXBYTES + 1];
+  int           curr_laa;
+  int           prev_laa;
+
+  if ( arab_debug )
+    fprintf(stderr,"ARABIC.c - offset = %d, char = 0x%x \n", offset, c);
+
+  /* Save away current character */
+  curr_c = c;
+
+  /* Deal only with Arabic characters */
+  if ( A_is_ok(c) )
+    {
+      /* Deal with ":set rightleft" orientation
+         - Obtain the previous and next offsets
+       */
+      if ( p_ri )
+        {
+          off_prev = offset - 1;
+          off_next = offset + 1;
+        }
+      else
+        {
+          off_prev = offset + 1;
+          off_next = offset - 1;
+        }
+
+      /* Get 'char' at previous offset */
+      fub[utfc_char2bytes(off_prev, fub)] = NUL;
+      prev_c = utfc_ptr2char(fub, &c1, &c2);
+
+      /* Get 'char' at next     offset */
+      fub[utfc_char2bytes(off_next, fub)] = NUL;
+      next_c = utfc_ptr2char(fub, &c1, &c2);
+
+      /* >>- Shape PREVIOUS character -<< */
+      if ( arab_debug )
+        {
+          fprintf(stderr,"arabic.c - PREV(%d): c = 0x%x \n", off_prev, prev_c);
+          fprintf(stderr,"arabic.c - CURR(%d): c = 0x%x \n", offset,   curr_c);
+          fprintf(stderr,"arabic.c - NEXT(%d): c = 0x%x \n", off_next, next_c);
+
+          fprintf(stderr,"arabic.c - (shape prev) - 0x%x\n", prev_c);
+        }
+
+      shape_c = 0;
+      if ( A_is_a(prev_c) )
+        shape_c = chg_c_a2i(prev_c);
+      else if ( A_is_valid(prev_c) && A_is_f(prev_c) )
+        shape_c = chg_c_f2m(prev_c);
+
+      /* Do the actual re-shaping on previous character */
+      if ( A_is_formb(shape_c) )
+        A_redo_shape(off_prev, shape_c);
+
+      /* >>- Shape CURRENT  character -<< */
+      curr_laa = A_firstc_laa(offset, c);
+      prev_laa = A_firstc_laa(off_prev, prev_c);
+
+      if ( arab_debug )
+        {
+          fprintf(stderr,"arabic.c - (shape curr) - 0x%x\n", curr_c);
+          fprintf(stderr,"arabic.c - curr_laa = 0x%x, prev_laa = 0x%x \n",
+                  curr_laa, prev_laa);
+        }
+
+      if ( curr_laa )
+        {
+          if (  A_is_valid(prev_c) && !A_is_f(shape_c) &&
+               !A_is_s(shape_c)    && !prev_laa )
+            curr_c = chg_c_laa2f(curr_laa);
+          else
+            curr_c = chg_c_laa2i(curr_laa);
+
+          /* Nullify the hidden char */
+          ScreenLinesC1[offset] = 0;
+        }
+      else if ( !A_is_valid(prev_c) && A_is_valid(next_c) )
+        curr_c = chg_c_a2i(c);
+      else if ( !shape_c || A_is_f(shape_c) || A_is_s(shape_c) || prev_laa )
+        curr_c = A_is_valid(next_c) ? chg_c_a2i(c)  : chg_c_a2s(c);
+      else if ( A_is_valid(next_c) )
+        curr_c = A_is_iso(c)        ? chg_c_a2m(c)  : chg_c_i2m(c);
+      else if ( A_is_valid(prev_c) )
+        curr_c = chg_c_a2f(c);
+      else
+        curr_c = chg_c_a2s(c);
+
+      /* Sanity check -- curr_c should, in the future, never be 0.
+         We should, in the future, insert a fatal error here.
+       */
+      if ( !curr_c )
+        {
+          if ( arab_debug )
+            fprintf(stderr,"arabic.c - error (!curr_c) - c = 0x%x \n", c);
+
+          curr_c = c;
+        }
+
+      /* Do the actual re-shaping on current character */
+      if ( A_is_formb(curr_c) )
+        A_redo_shape(offset, curr_c);
+
+      if ( arab_debug )
+        fprintf(stderr,"arabic.c - returing - c = 0x%x \n", curr_c);
+
+      return curr_c;
+
+    }
+  else
+    {
+      /* Deal only with Arabic character, pass back all others */
+      return c;
+    }
+}
+
+
+/*
+ * A_firstc_laa returns first character of LAA combination if it exists
+ *
+ */
+
+  int
+A_firstc_laa(offset, c)
+     int offset;
+     int c;
+{
+  char_u        fub[MB_MAXBYTES + 1];
+  int           temp_c;
+  int           c1 = 0;
+  int           c2 = 0;
+  
+  fub[utf_char2bytes(ScreenLinesC1[offset], fub)] = NUL;
+  temp_c = utfc_ptr2char(fub, &c1, &c2);
+
+  if ( temp_c && !A_is_harakat(temp_c) && (c == a_LAM) )
+    {
+      return temp_c;
+    }
+
+  return 0;
+}
+
+
+/*
+ * A_is_harakat returns TRUE if 'c' is an Arabic Harakat character
+ *              (harakat/tanween)
+ */
+
+  int
+A_is_harakat(c)
+     int c;
+{
+  return (
+          (c >= a_FATHATAN      && c <= a_SUKUN)
+         );
+}
+
+
+/*
+ * A_is_iso returns TRUE if 'c' is an Arabic ISO-8859-6 character
+ *          (alphabet/number/punctuation)
+ */
+
+  int
+A_is_iso(c)
+     int c;
+{
+  return (
+/*
+           c == a_COMMA                                 ||
+           c == a_SEMICOLON                             ||
+           c == a_QUESTION                              ||
+          (c >= a_ALEF_MADDA    && c <= a_GHAIN)        ||
+ */
+          (c >= a_HAMZA         && c <= a_GHAIN)        ||
+          (c >= a_TATWEEL       && c <= a_HAMZA_BELOW)  ||
+/*
+          (c >= a_ZERO          && c <= a_STAR)         ||
+ */
+           c == a_MINI_ALEF
+         );
+}
+
+
+/*
+ * A_is_formb returns TRUE if 'c' is an Arabic 10646-1 FormB character
+ *            (alphabet/number/punctuation)
+ */
+
+  int
+A_is_formb(c)
+     int c;
+{
+  return (
+          (c >= a_s_FATHATAN    && c <= a_s_DAMMATAN)   ||
+           c == a_s_KASRATAN                            ||
+          (c >= a_s_FATHA       && c <= a_f_LAM_ALEF)   ||
+           c == a_BYTE_ORDER_MARK
+         );
+}
+
+
+/*
+ * A_is_ok returns TRUE if 'c' is an Arabic 10646 (8859-6 or Form-B)
+ *
+ */
+
+  int
+A_is_ok(c)
+     int c;
+{
+  return ( A_is_iso(c) || A_is_formb(c) );
+}
+
+
+/*
+ * A_is_valid returns TRUE if 'c' is an Arabic 10646 (8859-6 or Form-B)
+ *            with some exceptions/exclusions
+ *
+ */
+
+  int
+A_is_valid(c)
+     int c;
+{
+  return ( A_is_ok(c) && !A_is_special(c) );
+}
+
+
+/*
+ * A_is_special returns TRUE if 'c' is not a special Arabic character.
+ *              Specials don't adhere to most of the rules.
+ *
+ */
+
+  int
+A_is_special(c)
+     int c;
+{
+  return ( c == a_HAMZA || c == a_s_HAMZA );
+}
--- /dev/null	Wed Feb 12 11:31:38 2003
+++ ./runtime/keymap/arabic.vim	Wed Feb 12 11:20:15 2003
@@ -0,0 +1,2 @@
+" Assume 'encoding' is set to "latin1" while actually iso-8859-6 is used
+source <sfile>:p:h/arabic_iso-10646-1.vim
--- /dev/null	Wed Feb 12 11:31:38 2003
+++ ./runtime/keymap/arabic_iso-10646-1.vim	Wed Feb 12 11:20:15 2003
@@ -0,0 +1,88 @@
+" $Id: arabic_shape.patch,v 1.8.2.1 2003/02/26 21:27:17 nadim Exp $
+"
+" Vim Keymap file for Arabic
+" Maintainer   : Arabic Support group <support@arabeyes.org>
+" Created by   : Nadim Shaikli <nadim@arabeyes.org>
+" Last Updated : Wed 8 Dec 2001 19:30:15
+" This is for a standard Microsoft Arabic keyboard layout.
+
+" Use this short name in the status line.
+let b:keymap_name = "arab"
+
+loadkeymap
+q       <char-0x0636>                   " (1590)        - DAD
+w       <char-0x0635>                   " (1589)        - SAD
+e       <char-0x062b>                   " (1579)        - THEH
+r       <char-0x0642>                   " (1602)        - QAF
+t       <char-0x0641>                   " (1601)        - FEH
+y       <char-0x063a>                   " (1594)        - GHAIN
+u       <char-0x0639>                   " (1593)        - AIN
+i       <char-0x0647>                   " (1607)        - HEH
+o       <char-0x062e>                   " (1582)        - KHAH
+p       <char-0x062d>                   " (1581)        - HAH
+[       <char-0x062c>                   " (1580)        - JEEM
+]       <char-0x062f>                   " (1583)        - DAL
+a       <char-0x0634>                   " (1588)        - SHEEN
+s       <char-0x0633>                   " (1587)        - SEEN
+d       <char-0x064a>                   " (1610)        - YEH
+f       <char-0x0628>                   " (1576)        - BEH
+g       <char-0x0644>                   " (1604)        - LAM
+h       <char-0x0627>                   " (1575)        - ALEF
+j       <char-0x062a>                   " (1578)        - TEH
+k       <char-0x0646>                   " (1606)        - NOON
+l       <char-0x0645>                   " (1605)        - MEEM
+;       <char-0x0643>                   " (1603)        - KAF
+'       <char-0x0637>                   " (1591)        - TAH
+z       <char-0x0626>                   " (1574)        - YEH with HAMZA ABOVE
+x       <char-0x0621>                   " (1569)        - HAMZA
+c       <char-0x0624>                   " (1572)        - WAW with HAMZA ABOVE
+v       <char-0x0631>                   " (1585)        - REH
+b       <char-0x0644><char-0x0627>      " (1604/1575)   - LAA (lam alef)
+n       <char-0x0649>                   " (1609)        - ALEF MAKSURA
+m       <char-0x0629>                   " (1577)        - TEH MARBUTA
+,       <char-0x0648>                   " (1608)        - WAW
+.       <char-0x0632>                   " (1586)        - ZAIN
+/       <char-0x0638>                   " (1592)        - ZAH
+0       <char-0x0660>                   " (1632)        - Arabic 0
+1       <char-0x0661>                   " (1633)        - Arabic 1
+2       <char-0x0662>                   " (1634)        - Arabic 2
+3       <char-0x0663>                   " (1635)        - Arabic 3
+4       <char-0x0664>                   " (1636)        - Arabic 4
+5       <char-0x0665>                   " (1637)        - Arabic 5
+6       <char-0x0666>                   " (1638)        - Arabic 6
+7       <char-0x0667>                   " (1639)        - Arabic 7
+8       <char-0x0668>                   " (1640)        - Arabic 8
+9       <char-0x0669>                   " (1641)        - Arabic 9
+`       <char-0x0630>                   " (1584)        - THAL
+~       <char-0x0651>                   " (1617)        - Tanween -- SHADDA
+Q       <char-0x064e>                   " (1614)        - Tanween -- FATHA
+W       <char-0x064b>                   " (1611)        - Tanween -- FATHATAN
+E       <char-0x064f>                   " (1615)        - Tanween -- DAMMA
+R       <char-0x064c>                   " (1612)        - Tanween -- DAMMATAN
+T       <char-0x0644><char-0x0625>      " (1604/1573)   - LAA  with HAMZA BELOW
+Y       <char-0x0625>                   " (1573)        - ALEF with HAMZA BELOW
+U       <char-0x0060>                   " (96)          - ASCII -- `
+I       <char-0x00f7>                   " (247)         - ASCII suppl -- div
+O       <char-0x00d7>                   " (215)         - ASCII suppl -- mul
+P       <char-0x061b>                   " (1563)        - Arabic Semicolon
+{       <char-0x003c>                   " (60)          - ASCII -- <
+}       <char-0x003e>                   " (62)          - ASCII -- >
+A       <char-0x0650>                   " (1616)        - Tanween -- KASRA
+S       <char-0x064d>                   " (1613)        - Tanween -- KASRATAN
+D       <char-0x005b>                   " (91)          - ASCII -- [
+F       <char-0x005d>                   " (93)          - ASCII -- ]
+G       <char-0x0644><char-0x0623>      " (1604/1571)   - LAA  with HAMZA ABOVE
+H       <char-0x0623>                   " (1571)        - ALEF with HAMZA ABOVE
+J       <char-0x0640>                   " (1600)        - TATWEEL
+K       <char-0x060c>                   " (1548)        - Arabic Comma
+L       <char-0x002f>                   " (47)          - ASCII -- /
+Z       <char-0x007e>                   " (126)         - ASCII -- ~
+X       <char-0x0652>                   " (1618)        - Tanween -- SUKUN
+C       <char-0x007b>                   " (123)         - ASCII -- {
+V       <char-0x007d>                   " (125)         - ASCII -- }
+B       <char-0x0644><char-0x0622>      " (1604/1570)   - LAA  with MADDA ABOVE
+N       <char-0x0622>                   " (1570)        - ALEF with MADDA ABOVE
+M       <char-0x0027>                   " (39)          - ASCII -- '
+<       <char-0x002c>                   " (44)          - ASCII -- ,
+>       <char-0x002e>                   " (46)          - ASCII -- .
+?       <char-0x061f>                   " (1567)        - Arabic Question Mark
--- ./runtime/doc/tags.orig	Mon Mar 25 09:00:34 2002
+++ ./runtime/doc/tags	Wed Feb 12 11:20:15 2003
@@ -30,6 +30,8 @@
 'altkeymap'	options.txt	/*'altkeymap'*
 'ap'	vi_diff.txt	/*'ap'*
 'ar'	options.txt	/*'ar'*
+'arab'	options.txt	/*'arab'*
+'arabic'	options.txt	/*'arabic'*
 'ari'	options.txt	/*'ari'*
 'as'	todo.txt	/*'as'*
 'autoindent'	options.txt	/*'autoindent'*
@@ -363,6 +365,8 @@
 'noallowrevins'	options.txt	/*'noallowrevins'*
 'noaltkeymap'	options.txt	/*'noaltkeymap'*
 'noar'	options.txt	/*'noar'*
+'noarab'	options.txt	/*'noarab'*
+'noarabic'	options.txt	/*'noarabic'*
 'noari'	options.txt	/*'noari'*
 'noas'	todo.txt	/*'noas'*
 'noautoindent'	options.txt	/*'noautoindent'*
@@ -918,6 +922,7 @@
 +GUI_Motif	various.txt	/*+GUI_Motif*
 +GUI_Photon	various.txt	/*+GUI_Photon*
 +X11	various.txt	/*+X11*
++arabic	various.txt	/*+arabic*
 +autocmd	various.txt	/*+autocmd*
 +balloon_eval	various.txt	/*+balloon_eval*
 +browse	various.txt	/*+browse*
@@ -1041,6 +1046,7 @@
 --servername	remote.txt	/*--servername*
 --socketid	starting.txt	/*--socketid*
 --version	starting.txt	/*--version*
+-A	starting.txt	/*-A*
 -C	starting.txt	/*-C*
 -D	starting.txt	/*-D*
 -E	starting.txt	/*-E*
@@ -2581,6 +2587,7 @@
 Abbreviations	map.txt	/*Abbreviations*
 Aleph	options.txt	/*Aleph*
 Amiga	os_amiga.txt	/*Amiga*
+Arabic	arabic.txt	/*Arabic*
 Atari	os_mint.txt	/*Atari*
 Athena	gui_x11.txt	/*Athena*
 B	motion.txt	/*B*
@@ -3159,6 +3166,7 @@
 E78	motion.txt	/*E78*
 E79	message.txt	/*E79*
 E80	message.txt	/*E80*
+E800	arabic.txt	/*E800*
 E81	map.txt	/*E81*
 E82	message.txt	/*E82*
 E83	message.txt	/*E83*
@@ -3532,6 +3540,8 @@
 ant.vim	syntax.txt	/*ant.vim*
 ap	motion.txt	/*ap*
 append()	eval.txt	/*append()*
+arabic  	arabic.txt	/*arabic*
+arabic.txt	arabic.txt	/*arabic.txt*
 argc()	eval.txt	/*argc()*
 argidx()	eval.txt	/*argidx()*
 arglist	editing.txt	/*arglist*
--- /dev/null	Wed Feb 19 13:27:45 2003
+++ ./runtime/doc/arabic.txt	Wed Feb 25 18:19:35 2003
@@ -0,0 +1,271 @@
+*arabic.txt*     For Vim version 6.1.  Last change: 2003 Feb 25
+
+
+                  VIM REFERENCE MANUAL    by Nadim Shaikli
+
+
+Right to Left and Arabic Mapping for Vim	*arabic* *Arabic*
+
+{Vi does not have any of these commands}
+
+                                                *E800*
+In order to use right-to-left and Arabic mapping support, it is
+necessary to compile VIM with the |+arabic| feature.
+
+These functions have been created by Nadim Shaikli <nadim@arabeyes.org>
+
+It best to view this file with ':set encoding=utf-8' in VIM's GUI ~
+
+Introduction
+------------
+Arabic is a rather demanding language in which a number of special
+features are required.  Characters are right-to-left oriented and
+ought to appear as such on the screen (ie. from right to left).
+Arabic also requires shaping of its characters, meaning the same
+character has a different visual form based on its relative location
+with a word (initial, medial, final or stand-alone).  Arabic also
+requires the ability to combine certain characters in which two
+characters get combined visually to look as though its one.  Lastly,
+to display Arabic properly one will require not only ISO-8859-6
+(U+0600-U+06FF) fonts, but will also require Presentation Form-B
+(U+FE70-U+FEFF) fonts.
+
+The commands, prompts and help files are not in Arabic, therefore
+the user interface remains the standard Vi interface.
+
+
+Highlights
+----------
+o  Editing left-to-right files as in the original VIM no change.
+
+o  Viewing and editing files in right-to-left windows.   File
+   orientation is per window, so it is possible to view the same
+   file in right-to-left and left-to-right modes, simultaneously.
+
+o  No special terminal with right-to-left capabilities is required.
+   The right-to-left changes are completely hardware independent.
+   Only Arabic fonts are necessary.
+
+o  Compatibility to the original VIM.   Almost all features work in
+   right-to-left mode (there are liable to be bugs).
+
+o  Changing keyboard mapping and reverse insert modes using a single
+   command.
+
+o  Toggling complete Arabic support via a single command.
+
+o  While in Arabic mode, numbers are entered from left to right. Upon
+   entering a none number character, that character will be inserted
+   just into the left of the last number.
+
+o  Arabic keymapping on the command line in reverse insert mode.
+
+o  Proper Bidirectional functionality is possible given VIM is
+   started within a Bidi capable terminal emulator.
+
+
+Arabic Fonts                                    *arabic fonts*
+-----------
+
+VIM requires monospaced fonts of which there are many out there.
+Arabic requires ISO-8859-6 as well as Presentation Form-B fonts
+(without Form-B, Arabic will _NOT_ be usable).  It is highly
+recommended that users search so-called 'ISO-10646-1' fonts.
+Do an internet search or check www.arabeyes.org for further
+info on where to attain the necessary Arabic fonts.
+
+
+Font Installation
+-----------------
+
+o  Installation of fonts for X Window systems (Unix/Linux)
+
+   Depending on your system, copy you_ARABIC_FONT_FILENAME into
+   a directory of your choice.  Change to the directory containing
+   the Arabic fonts and execute the following commands:
+
+     %  mkfontdir
+     %  xset +fp path_name_of_arabic_fonts_directory
+
+
+Usage
+-----
+Prior to the actual usage of Arabic within VIM, a number of settings
+need to be accounted for and invoked.
+
+o  Setting the Arabic fonts
+
+   +  For VIM GUI set the 'guifont' to you_ARABIC_FONT. This is done
+      by entering the following command in the VIM window.
+
+        :set guifont=your_ARABIC_FONT
+
+      NOTE: the string 'your_ARABIC_FONT' is used to denote a complete
+            font name akin to that used in linux/unix system.
+            (eg. -misc-fixed-medium-r-normal--20-200-75-75-c-100-iso10646-1)
+
+      You can append the 'guifont' set command to your .vimrc file
+      in order to get the same above noted results.  In other words,
+      you can include ':set guifont=you_ARABIC_FONT' to your .vimrc
+      file.
+
+      Under the X Window environment, you can also start the VIM with
+      '-fn you_ARABIC_FONT' option.
+
+o  Enable Arabic settings [short-cut]
+
+   In order to simplify and streamline things, you can either invoke
+   VIM with the command-line option,
+
+     % vim -A ...
+
+   or enable 'arabic' via the following command within VIM
+
+     :set arabic
+
+   Both options accomplish,
+
+     1. set the encoding to utf-8
+     2. set the appropriate keymap
+     3. enable rightleft mode
+     4. enable the deletion of the single combined pair
+ 
+   You can also append the command to your .vimrc file and simply
+   include ':set arabic' to it.
+
+   You are also capable of disabling Arabic support via
+
+     :set noarabic
+
+   which attempts to bring back VIM's settings as close to what they
+   were as possible.
+
+   If, on the other hand, you'd like to be verbose and explicit and
+   not use the ':set arabic' short-cut command, here's what is needed
+   (ie. if you use ':set arabic' you can skip this section) -
+
+   +  Arabic Encoding Selection
+
+      To enable the correct Arabic encoding the following command needs
+      to entered
+
+        :set encoding=utf-8
+
+      in your VIM window.  You can also append the 'encoding' set command to
+      your .vimrc file.  In other words, you can include ':set encoding=utf-8'
+      to your .vimrc file.
+
+   +  Arabic Keymapping Activation
+
+      To activate the Arabic keymap (ie. to remap your english/latin
+      keyboard to look-n-feel like a standard Arabic one), set the
+      'keymap' command to "arabic".  This is done by entering
+
+        :set keymap=arabic
+
+      in your VIM window.  You can also append the 'keymap' set command to
+      your .vimrc file.  In other words, you can include ':set keymap=arabic'
+      to your .vimrc file.
+
+      To turn toggle (or switch) your keymapping between Arabic and the
+      default mapping (english), its advised that users use the 'CTRL-^'
+      key press while in insert (or add/replace) mode.  The command-line
+      will display your current mapping by displaying an "Arabic" string
+      next to your insertion mode (eg. -- INSERT Arabic --) indicating
+      your current keymap.
+
+   +  Arabic right-to-left Mode
+
+      By default VIM starts in Left-to-right mode.  The following are ways
+      to change the window orientation:
+
+      - To toggle between left-to-right and right-to-left modes, use
+        ':set rightleft' and ':set norightleft'.
+
+      - While in Left-to-right mode, enter ':set rl' in the command line
+        ('rl' is the abbreviation for rightleft).
+
+      - Put the ':set rl' line in your '.vimrc' file to start the VIM in
+        right-to-left mode permanently.
+
+   +  Arabic deletion of a combined pair character
+
+      By default VIM has the 'delcombine' option disabled.  This option
+      allows the deletion of ALEF in a LAM_ALEF (LAA) combined character
+      and still retain the LAM (ie. it reverts to treating the combined
+      character as its natural two characters form -- this also pertains
+      to harakat and their combined forms).  You can enable this option
+      by entering
+
+        :set delcombine
+
+      in our VIM window.  You can also append the 'delcombine' set command
+      to your .vimrc file.  In other words, you can include ':set delcombine'
+      to your .vimrc file.
+
+
+Keymap/Keyboard
+---------------
+
+The character/letter encoding used in VIM is the standard UTF-8.
+It is widely discouraged that any other encoding be used or even
+attempted.
+
+Note: UTF-8 is an all encompassing encoding and as such is
+      the only supported (and encouraged) encoding with
+      regard to Arabic (all other proprietary encodings
+      should be discouraged and frowned upon).
+
+o  Keyboard
+
+   +  CTRL-^ in insert/replace mode toggles between Arabic/Latin mode
+
+   +  Keyboard mapping is based on the Microsoft's Arabic keymap (the
+      defacto standard in the Arab world):
+
+  +---------------------------------------------------------------------+
+  |!   |@   |#   |$   |%   |^   |&   |*   |(   |)   |_   |+   ||   |~  ّ |
+  |1 ١ |2 ٢ |3 ٣ |4 ٤ |5 ٥ |6 ٦ |7 ٧ |8 ٨ |9 ٩ |0 ٠ |-   |=   |\   |` ذ |
+  +---------------------------------------------------------------------+
+       |Q  َ |W  ً |E  ُ |R  ٌ |T لإ |Y إ |U ` |I I |O x |P ؛ |{ < |} > |
+       |q ض |w ص |e ث |r ق |t ف |y غ |u ع |i ه |o خ |p ح |[ ج |] د |
+       +-----------------------------------------------------------+
+         |A  ِ |S  ٍ |D [ |F ] |G لأ |H أ |J ـ |K ، |L / |:   |"   |
+         |a ش |s س |d ي |f ب |g ل |h ا |j ت |k ن |l م |; ك |' ط |
+         +------------------------------------------------------+
+           |Z ~ |X  ْ |C { |V } |B لآ |N آ |M ' |< , |> . |? ؟ |
+           |z ئ |x ء |c ؤ |v ر |b لا |n ى |m ة |, و |. ز |/ ظ |
+           +-------------------------------------------------+
+
+Restrictions
+------------
+
+o  VIM does not natively currently support Bi-directionality (ie. the
+   ability to see both Arabic and Latin intermixed within the same line).
+
+o  In the command mode, there is no support for entering the numbers from
+   left to right.
+
+
+Known Bugs
+----------
+
+There is one known minor bug,
+
+ 1. If you insert a haraka (eg. Fatha (U+064E)) after a LAM (U+0644)
+    and then insert an ALEF (U+0627), the appropriate combining will
+    not happen due to the sandwiched haraka resulting in something
+    that will NOT be displayed correctly.
+
+    WORK-AROUND: Don't include harakats between LAM and ALEF combos.
+                 In general, don't anticipate to see correct visual
+                 representation with regard to harakats and LAM+ALEF
+                 combined characters (even those entered after both
+                 characters).  The problem noted is strictly a visual
+                 one, meaning saving such a file will contain all the
+                 appropriate info/encodings - nothing is lost.
+
+No other bugs are known to exist.
+
+ vim:tw=78:ts=8:ft=help:norl:
+
--- ./runtime/doc/options.txt.orig	Thu Jan  9 13:14:38 2003
+++ ./runtime/doc/options.txt	Wed Feb 12 11:20:15 2003
@@ -586,6 +586,21 @@
 	mode) and have default second language Farsi or Hebrew (right-to-left
 	mode).  See |farsi.txt|.
 
+			*'arabic'* *'arab'* *'noarabic'* *'noarab'*
+'arabic' 'arab'		boolean (default off)
+			global
+			{not in Vi}
+			{only available when compiled with the |+arabic|
+			feature}
+	When on, the second language is Arabic. In editing mode CTRL-^
+        toggles the keyboard map between Arabic and English.  When on,
+        this option forces the 'encoding' to utf-8, the 'keymap' to Arabic
+        for proper keyboard mapping and it enables the 'rightleft' mode.
+
+        When disabled (via noarabic), the encoding, keymap as well as
+        rightleft is returned to their default states.
+        Also see |arabic.txt|.
+
 			*'autoindent'* *'ai'* *'noautoindent'* *'noai'*
 'autoindent' 'ai'	boolean	(default off)
 			local to buffer
--- ./runtime/doc/quickref.txt.orig	Mon Mar 25 09:00:34 2002
+++ ./runtime/doc/quickref.txt	Wed Feb 12 11:20:15 2003
@@ -588,6 +588,7 @@
 |'aleph'|	  |'al'|     ASCII code of the letter Aleph (Hebrew)
 |'allowrevins'|	  |'ari'|    allow CTRL-_ in Insert and Command-line mode
 |'altkeymap'|	  |'akm'|    for default second language (Farsi/Hebrew)
+|'arabic'|	  |'arab'|   for Arabic as a default second language
 |'autoindent'|	  |'ai'|     take indent for new line from previous line
 |'autoread'|	  |'ar'|     autom. read file when changed outside of Vim
 |'autowrite'|	  |'aw'|     automatically write file if changed
@@ -1120,6 +1121,7 @@
 |-m|	-m		    modifications not allowed (resets 'write' option)
 |-b|	-b		    binary mode
 |-l|	-l		    lisp mode
+|-A|	-A		    Arabic mode ('arabic' is set)
 |-F|	-F		    Farsi mode ('fkmap' and 'rightleft' are set)
 |-H|	-H		    Hebrew mode ('hkmap' and 'rightleft' are set)
 |-V|	-V		    Verbose, give informative messages
--- ./runtime/doc/starting.txt.orig	Fri Aug 30 17:54:00 2002
+++ ./runtime/doc/starting.txt	Wed Feb 26 13:54:01 2003
@@ -266,7 +266,13 @@
 							*-l*
 -l		Lisp mode.  Sets the 'lisp' and 'showmatch' options on.
 
-							*-F*
+							*-A*
+-A		Arabic mode.  Sets the 'arabic' option on.  (Only when
+		compiled with the |+arabic| features (which include
+		|+rightleft|), otherwise Vim gives an error message
+		and exits.  {not in Vi}
+
+							*-H*
 -F		Farsi mode.  Sets the 'fkmap' and 'rightleft' options on.
 		(Only when compiled with |+rightleft| and |+farsi| features,
 		otherwise Vim gives an error message and exits).  {not in Vi}
--- ./runtime/doc/rileft.txt.orig	Mon Mar 25 09:00:34 2002
+++ ./runtime/doc/rileft.txt	Wed Feb 12 11:20:15 2003
@@ -70,9 +70,11 @@
    To create a Hebrew font for a DOS box under MS-Windows, refer to a hack on
    ftp://tochna.technion.ac.il/pub/staff/lottem/doswin-0.1.tgz.
 
-o  It should be quite easy to adjust this support to handle other right-to
-   left languages, such as Arabic, by simply changing the keyboard mapping
-   according to the character encoding.
+o  Many other languages that use and require right-to-left support can
+   quite easily be supported given the inclusion of their required keyboard
+   mappings and some possible minor code change.  Some of these languages
+   (such as |arabic| and |farsi|) have already added their required code
+   and mappings.
 
 
 Change details
--- ./runtime/doc/vi_diff.txt.orig	Mon Mar 25 09:00:35 2002
+++ ./runtime/doc/vi_diff.txt	Wed Feb 12 11:20:15 2003
@@ -781,6 +781,8 @@
 -f		Vim: Run GUI in foreground (Amiga: don't open new window).
 -f {session}	Elvis: Use {session} as the session file.
 
+-A		Vim: Start in Arabic mode (when compiled with Arabic).
+
 -F		Vim: Start in Farsi mode (when compiled with Farsi).
 		Nvi: Fast start, don't read the entire file when editing
 		starts.
--- ./runtime/doc/eval.txt.orig	Wed Jan 29 08:45:07 2003
+++ ./runtime/doc/eval.txt	Wed Feb 26 13:54:01 2003
@@ -2425,6 +2425,7 @@
 
 all_builtin_terms	Compiled with all builtin terminals enabled.
 amiga			Amiga version of Vim.
+arabic			Compiled with Arabic support |arabic|.
 arp			Compiled with ARP support (Amiga).
 autocmd			Compiled with autocommands support.
 balloon_eval		Compiled with |balloon-eval| support.
--- ./runtime/doc/help.txt.orig	Mon Mar 25 09:00:32 2002
+++ ./runtime/doc/help.txt	Wed Feb 12 11:20:15 2003
@@ -128,6 +128,7 @@
 |fold.txt|	hide (fold) ranges of lines
 
 Special issues ~
+|arabic.txt|	Arabic language support and editing
 |remote.txt|	using Vim as a server or client
 |term.txt|	using different terminals and mice
 |digraph.txt|	list of available digraphs
--- ./runtime/doc/Makefile.orig	Sun Sep 16 13:57:47 2001
+++ ./runtime/doc/Makefile	Wed Feb 12 11:20:15 2003
@@ -11,6 +11,7 @@
 include ../../src/auto/config.mk
 
 DOCS = \
+	arabic.txt \
 	autocmd.txt \
 	change.txt \
 	cmdline.txt \
@@ -124,6 +125,7 @@
 	workshop.txt
 
 HTMLS = \
+	arabic.html \
 	autocmd.html \
 	change.html \
 	cmdline.html \
@@ -291,6 +293,9 @@
 	-rm doctags *.html tags.ref
 
 # These files are in the extra archive, skip if not present
+
+arabic.txt:
+	touch arabic.txt
 
 farsi.txt:
 	touch farsi.txt
--- ./runtime/doc/vim.1.orig	Mon Feb 25 08:44:31 2002
+++ ./runtime/doc/vim.1	Wed Feb 12 11:20:15 2003
@@ -149,6 +149,17 @@
 processing any vimrc file.
 You can use up to 10 of these commands, independently from "-c" commands.
 .TP
+-A
+If
+.B Vim
+has been compiled with ARABIC support for editing right-to-left
+oriented files and Arabic keyboard mapping, this option starts
+.B Vim
+in Arabic mode, i.e. 'arabic' is set.  Otherwise an error
+message is given and
+.B Vim
+aborts.
+.TP
 -b
 Binary mode.
 A few options will be set that makes it possible to edit a binary or
